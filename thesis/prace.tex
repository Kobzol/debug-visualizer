\documentclass[bc,male,java,dept460]{diploma}						% jednostranny dokument
%\documentclass[bc,male,java,dept460,twoside]{diploma}		% oboustranny dokument
\usepackage[czech]{babel}
\usepackage[backend=biber,sorting=none]{biblatex}
\addbibresource{references.bib}

% remark - poznámka
% definition - definice
% theorem - věta
% example - příklad
% \begin{lstlisting}[label=src:Java,caption=Program v jazyce Java]
% \lstinputlisting[label=src:JavaExternal,caption={Program v jazyce Java, načtený z externího souboru}]{MyClass.java}
% \InsertFigure{Figures/Obr1}{40mm}{Pokusný obrázek -- absolutní velikost}{fig:SampleFigAbs}
% \InsertFigure{Figures/Obr1}{0.7\textwidth}{Pokusný obrázek -- relativní velikost}{fig:SampleFigRel}
% \InsertSidewaysFigure{Figures/Obr1}{0.6\textheight}{Pokusný obrázek -- otočený naležato}{fig:SampleFigSideway}

\ThesisAuthor{Jakub Beránek}
\ThesisTitle{Vizualizace ladění aplikací}
\EnglishThesisTitle{Visualization of application debugging}

\SubmissionDate{29. dubna 2016}

\PrintPublicationAgreement{true}

\AccessRestriction{Zde vložte text dohodnutého omezení přístupu k Vaší práci, chránící například firemní know-how.
Zde vložte text dohodnutého omezení přístupu k Vaší práce, chránící například firemní know-how.
A zavazujete se, že\par
\begin{enumerate}
\item o práci nikomu neřeknete,
\item po obhajobě na ni zapomenete a
\item budete popírat její existenci.
\end{enumerate}
A ještě jeden důležitý odstavec. A ještě jeden důležitý odstavec.
A ještě jeden důležitý odstavec. A ještě jeden důležitý odstavec.
A ještě jeden důležitý odstavec. A ještě jeden důležitý odstavec.
Konec textu dohodnutého omezení přístupu k Vaší práci.}

\Thanks{Rád bych na tomto místě poděkoval všem, kteří mi s prací pomohli, protože bez nich by tato práce nevznikla.}

\CzechAbstract{Tato bakalářská práce se zabývá vizualizací ladění programů napsaných v jazyce C a C++. První část popisuje
obecné principy ladění programů. Jsou zde popsány konstrukce, které se při ladění používají, způsob, jakým ladící nástroje
provádějí ladění programů a také existující ladících nástrojy a jejich grafické nástavby. Druhá část popisuje možnosti komunikace
s ladícími nástroji. Je v ní popsána implementace grafického nástroje, který vizualizuje pamět a stav procesu během jeho ladění
za využití existujících ladících nástrojů  }

\CzechKeywords{ladění programů, vizualizace paměti}

\EnglishAbstract{This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract.}

\EnglishKeywords{typography, \LaTeX, master thesis}

\AddAcronym{API}{Application Programmable Interface}
\AddAcronym{GDB}{The GNU Project Debugger}
\AddAcronym{GNU}{GNU's Not Unix!}


% Zadame cestu a jmeno souboru ci nekolika souboru s digitalizovanou podobou zadani prace
% Pri sazbe se pak hledaji soubory Figures/Zadani1.jpg, Figures/Zadani2.jpg atd.
% Do diplomove prace se postupne vlozi vsechny existujici soubory Figures/ZadaniXXX.jpg
% Pokud toto makro zapoznamkujeme sazi se stranka s upozornenim
%\ThesisAssignmentImagePath{Figures/Zadani}

% Zadame soubor s digitalizovanou podobou prohlaseni
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni
\DeclarationImageFile{Figures/Prohlaseni.jpg}

% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
\listoftables
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
\listoffigures
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
\lstlistoflistings
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Zacneme uvodem
\section{Úvod}
	Ladění je nezbytná součást vývoje programů, která dovoluje programátorům detailně sledovat a ovládat průběh běžícího procesu a také
	číst a zapisovat jeho paměť. K tomuto slouží ladící nástroje, které vytváří asociaci mezi zdrojovým kódem a binárním spustitelným
	souborem a poskytují tak tvůrci kódu možnost ladit kód na vysoké úrovni abstrakce, tj. na úrovni samotného zdrojového kódu.
	
\section{Principy ladění programů}
	Tato kapitola popisuje obecné principy fungování ladících nástrojů, způsob mapování binárních instrukcí programu zpět do jeho zdrojového kódu,
	krokování běžícího procesu a běžné konstrukce používané při ladění. Konkrétně je popis zaměřen na programy napsané v jazycích C a C++
	v prostředí UNIXových systémů na platformě Intel x86. Popsané principy jsou ale obecné a lze je aplikovat na libovolnou operační systém.
		
	\subsection{Signály}
		Pro ladění programu je nutné mít možnost číst jeho paměť, aby šly zkoumat hodnoty proměnných za jeho běhu, a také ho zastavit, jelikož
		programy za běhu provádějí obrovské množství instrukcí za vteřinu a zkoumat takto rychle se měnící datový tok by bylo obtížné.
		Aby šlo proces zastavit, musí mu jiný proces anebo sám operační systém zaslat signál.
		Signály jsou zprávy, které lze zaslat běžícímu procesu, ten si je může odchytit a zareagovat na ně.\cite[21]{tanenbaum}
		Slouží pro meziprocesní komunikaci a fungují jako softwarová obdoba hardwarových přerušení procesoru.
		Jakmile proces obdrží signál, který očekává, tak si uloží hodnoty svých registrů a přejde do procedury, která tento signál obslouží.
		Pokud proces obdrží signál, pro který si nepřipravil žádnou reakci, tak se provede implicitně nadefinovaná akce pro daný typ signálu.
		V UNIXových systémech je definováno několik desítek standardních signálů, v závislosti na verzi a typu operačního systému.
		Na signály SIGKILL, sloužící k okamžitému ukončení procesu a SIGSTOP, sloužící k zastavení procesu, nemá proces možnost zareagovat ani
		zjistit, že mu byly poslány.
	
	\subsection{Krokování}
		Operační systémy obvykle poskytují nástroj, pomocí kterého lze buď spustit proces, anebo se připojit k již běžícímu procesu, a následně ho ovládat
		a přistupovat k jeho paměti. UNIXové systémy pro tento účel poskytují systémové volání \textbf{ptrace}\cite{ptrace}, které umožňuje zachytávat signály
		zaslané sledovanému procesu. Proces sledovaný pomocí funkce ptrace je zastaven při přijetí jakéhokoliv signálu (kromě signálu SIGKILL, který se pokusí proces
		okamžitě ukončit). Tohoto mechanismu využívají ladící nástroje, které proces sledovaný pomocí ptrace můžou po jeho zastavení znovu spustit,
		přistupovat k jeho paměti a ovlivňovat jeho průběh. Pokud je sledovaný proces potomkem procesu, který ho sleduje, bude při jeho spuštění vyvolán
		signál SIGTRAP, který dovolí rodičovi odchytit začátek provádění potomka. Jakmile je proces zastavený, může ho ladící nástroj tzv. krokovat, tedy spouštět
		instrukci po instrukci. K tomu lze použít funkci ptrace s příznakem PTRACE\_SINGLESTEP, která provede přesně jednu instrukci v laděném procesu (proces se také
		zastaví, pokud se dostane na vstupní nebo výstupní bod systémového volání)\cite{ptrace}. Ladící nástroje obvykle nabízí krokování na vyšší úrovni než
		pouze po jedné instrukci, jelikož to by bylo zbytečně zdlouhavé (u vyšších programovacích jazyků se jeden řádek zdrojového kódu může mapovat na desítky
		až stovky instrukcí). Obvykle jsou dostupné následující typy krokování:
		\begin{description}
			\item[Step over] - krokování po řádku zdrojového kódu
			\item[Step in] - stejná funkce jako step over, ale program se zastaví, pokud vstoupí dovnitř funkce
			\item[Step out] - program bude pokračovat, dokud neskončí funkce, ve které se právě nachází
		\end{description}
		
	\subsection{Obousměrné mapování zdrojového kódu na instrukce}
		Aby mohly ladící nástroje nabízet krokování na úrovni (řádků) zdrojového kódu, musí umět namapovat zdrojový kód na instrukce vygenerovaného
		spustitelného programu i instrukce zpět na zdrojový kód. Jelikož programy psané v jazycích C a C++ jsou kompilované a po jejich překladu nejsou
		ve výsledném binárním souboru téměř žádné informace o jejich zdrojovém kódu, musí být přeloženy ve speciálním režimu, který při překladu vygeneruje
		metadata s mapováním zdrojového kódu a vloží je do přeloženého programu. V překladačích jazyka C/C++ se tohoto dá standardně dosáhnout použitím
		řepínače \textbf{-g}. Existuje několik formátů ukládání těchto metadat, dnešním de facto standardem na UNIXových systémech je DWARF\cite{dwarf}.
		Ten ukládá proměnné, datové typy, procedury a další údaje ze zdrojového kódu ve stromové struktuře. Pro ušetření místa obsahuje instrukce pro
		speciální konečný automat, který implementují ladící nástroje a pomocí něho poté získávají informace o původním zdrojovém kódu.
		
		\vspace{5mm}
		
		\par Samotné mapování zdrojového kódu není pro ladící nástroj užitečné, pokud je výsledný program zoptimalizovaný překladačem. Po optimalizaci
		totiž program nemusí obsahovat všechny původní proměnné, funkce a jeho průběh ani nemusí přesně odpovídat jeho zdrojovému kódu. Při použité málo agresivní
		optimalizace někdy lze programy úspěšně ladit, ale pro zajištění co nejpřesnějšího ladění programů je obvykle nutné optimalizace úplně vypnout. Toho lze
		v překladačích obvykle dosáhnout použitím přepínače \textbf{-O0}.
	
	\subsection{Běžné konstrukce ladících nástrojů}
		\begin{description}
			\item[Breakpoint]
				Většina ladících nástrojů poskytuje svým uživatelům možnost zastavit běh laděného procesu pomocí tzv. breakpointu.
				Jedná se o označení řádku v zdrojovém kódu programu, na kterém se program za běhu zastaví a umožní tak uživateli prozkoumat paměť procesu a krokovat ho.
				Nejčastěji je implementován tak, že ladící nástroj nejdříve zjistí z daného řádku adresu instrukce ve vygenerovaném spustitelném souboru, kterou tento
				řádek představuje, uloží si ji a nahradí ji instrukcí přerušení s kódem 3. Toto přerušení je určeno speciálně pro ladění procesů, jelikož generuje
				instrukci o velikosti jednoho bytu, a lze jím tak nahradit libovolnou instrukci\cite[306]{intel}. Pokud by měla více než jeden byte, mohlo by ses
				stát, že by tato instrukce přepsala více než jednu instrukci, což by mohlo způsobit nevalidní chování programu. Jakmile program během svého běhu
				provede tuto instrukci, vyvolá se signál SIGTRAP, který ladící nástroj odchytí a laděný proces se tímto zastaví. Pokud se uživatel rozhodne proces
				opět sputit, ladící nástroj zkopíruje původní instrukci programu (kterou si dříve uložil) na místo, kde vložil přerušení, nastaví na ni ukazatel
				příští instrukce a proces opět spustí.
				Některé procesory nabízí také hardwarový breakpoint, který sice může být rychlejší, ale obvykle kvůli tomu, že je implementován v hardwaru, tak poskytuje
				vytvoření pouze několika breakpointů zároveň.
			\item[Tracepoint]
				V některých případech není možné laděný proces pozastavit k prozkoumání jeho paměti, jelikož jeho průběh může záviset na reálně uběhlém čase a zastavení
				tedy může způsobit, že program neproběhne korektně. Pro tyto situace lze použít tracepoint, u kterého se uvede lokace v programu a paměť, která má být
				sledována. Pokaždé, když se laděný proces dostane na tuto lokaci, tak je uložena sledovaná paměť a po skončení běhu procesu si lze zpětně prohlédnout,
				jak se tato paměť v průběhu programu měnila.
			\item[Watchpoint]
				Pokud je potřeba zastavit program ne na konkrétním místě, ale při změně dané hodnoty v paměti, lze použít watchpoint. Ten se může hodit například pro
				kontrolu změn globálních proměnných. Pokud nenabízí procesor hardwarovou podporu pro watchpointy, ladící nástroj prochází laděný proces instrukci po
				instrukci, testuje hodnotu sledované paměti a pokud se tato hodnota změní, tak program zastaví. Tento proces může zpomalit laděný proces až o
				dva řády\cite{gdb-watchpoint}.
			\item[Catchpoint]
				Tuto konstrukci lze použít pro zachycení událostí procesu, jako jsou načtení sdílené knihovny, vyvolání hardwarové či softwarové výjimky, provedení
				systémového volání anebo přijetí signálu. Většina těchto událostí je ze své podstaty asynchronní, nelze u nich tedy dopředu určit, kdy budou zavolány
				a použití breakpointu tedy není možné.
		\end{description}
		
\section {Existující ladící nástroje}
	Ladících nástrojů pro jazyky C a C++ existuje velké množství, v této kapitole jsou popsány dva z nejpoužívanějších nástrojů, GDB a LLDB, které byly dále
	použity při implementaci vizualizačního nástroje. Jsou zde taky popsány jejich vybrané grafické nádstavby.

	\subsection{GDB}
		GDB (The GNU Debugger) je standardním ladícím nástrojem pro UNIXové systémy, často je v těchto systémech už předinstalovaný.
		Jeho hlavním zaměřením je ladění programů napsaných v jazycích C a C++, ale podporuje mimo jiné i Adu, Objective-C, Pascal, Fortran, Javu
		a Go\cite{gdb-languages}. Podporuje velké množství rodin procesorů, například ARM, AVR, Itanium, MIPS, PowerPC, SPARC a samozřejmě x86 i x86-64.
		Lze jej spustit i na platformě Windows pomocí prostředí emulujících UNIX (např. Cygwin nebo MinGW). Byl vydán v roce 1986 a k roku
		2016 stále vycházejí nové verze. 
		
		\par GDB obsahuje základní funkce nezbytné pro každý ladící nástroj, jako je načtení
		ladících metadat v mnoha formátech (podporuje DWARF i několik dalších formátů), vytváření breakpointů, tracepointů a watchpointů, krokování programu a
		čtení i zápis paměti programu. Mimo to ale nabízí i pokročilé funkce, které nemusí být podporované všemi procesory a platformami.
		
		\begin{description}
			\item[Vzdálené ladění]
				GDB dokáže být spuštěno na jednom zařízení, a ladit program spuštěný na jiném zařízení pomocí síťové komunikace (obvykle pomocí protokolu TCP).
				Toto může být užitečné, pokud není dostupný fyzický přístup k systému, který je potřeba odladit.
				Vzdálené ladění se dá využít také k ladění jádra (kernelů) operačního systému, čehož je využito například v programu KGDB, který slouží k ladění
				jader operačních systémů Linux a FreeBSD pomocí sériového připojení.
			\item[Ladění vícevláknových aplikací]
				Pokud GDB ladí program, který využívá více než jedno vlákno, může pracovat v několika rozlišných módech\cite{gdb-multithreading}.
				V All-stop módu se při zastavení jednoho vlákna zastaví také všechna ostatní vlákna, aby šlo mezi vlákny přepínat a číst jejich paměť bez toho,
				aby se paměť mezitím nějak změnila. Pokud je nutné zastavit pouze jedno vlákno, tak, aby ostatní pokračovala v běhu, lze použít tzv. Non-stop mód,
				který vždy zastaví pouze vlákno, které narazí na breakpoint, a zbytek vláken nechá běžet. S tímto módem je vhodné použít asynchronní ovládání GDB,
				pomocí kterého lze zasílat ladící příkazy programu i za jeho běhu a ovládat tak pouze zastavené vlákno, i když zbytek vláken stále běží.
			\item[Provádění výrazů]
				Pomocí GDB lze nejenom číst a zapisovat paměť laděného procesu na úrovni bytů v adresním prostoru procesu, ale v podporovaných jazycích, hlavně
				v C a C++, lze také provádět libovolné jazykové výrazy, volat funkce programu a systémová volání a pracovat s hodnotami na úrovni proměnných
				laděného programu.
			\item[Spolupráce s Valgrindem]
				Valgrind je nástroj pro profilování a kontrolu paměťové korektnosti programů, který se využívá k hledání paměťových chyb, jako je například memory
				leak. Vytváří virtuální stroj, ve kterém spouští zkoumaný program a kvůli této vlastnosti jej nelze ladit klasickými přístupy. GDB poskytuje
				možnost připojit se k programu spuštěnému ve Valgrindu a vzdáleně ho takto ladit.
			\item[Zpětné provádění instrukcí]
				Při ladění nastává často situace, kdy proces zajde moc daleko a přeskočí instrukci, kterou chce uživatel zkoumat. GDB umí spouštět určité instrukce
				zpětně, a může tedy krokovat program nejenom dopředu, ale i dozadu. Všechny změny a vedlejší efekty, které proběhly v paměti, jsou tak smazány a
				navráceny do původního stavu (pokud to daná platforma a stav programu dovoluje).
		\end{description}
		
		GDB nemá vlastní grafické rozhraní, je ovládán z příkazové řádky. Kromě toho ale podporuje také spouštění skriptů v Pythonu pomocí API,
		které bylo použito pro implementaci vizualizačního nástroje a je popsáno dále v textu.
	\subsection{LLDB}
	
	\subsection{Srovnání LLDB s GDB}

	\subsection{Grafické nádstavby}

\section{Popis problému}

\section{Návrh řešení}
	\subsection{Komunikace s ladícím nástrojem}
		\subsection{Python API pro GDB}
		\subsection{Python API pro LLDB}
		\subsection{Protokol GDB/MI}
		
	\subsection{Vizualizační část}
	
\section{Implementace}
	\subsection{Ovládání laděného procesu}
	\subsection{Vizualizace paměti procesu}

\section{Závěr}
\label{sec:Conclusion}

\bigskip
\begin{flushright}
Jakub Beránek
\end{flushright}

%\printbibliography
\printbibheading[title=Reference, heading=bibintoc]
\printbibliography[type=book,heading=subbibintoc,title={Knižní zdroje}]
\printbibliography[nottype=book,heading=subbibintoc,title={Online zdroje}]

\appendix
\clearpage

\end{document}
