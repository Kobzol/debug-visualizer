\documentclass[bc,male,python,dept460]{diploma}						% jednostranny dokument

\usepackage[english, czech]{babel}
\usepackage[T1]{fontenc}
\usepackage[
	backend=biber,
	autolang=other,
	style=iso-numeric,
	sorting=none,
	sortlocale=cs_CZ,
  bibencoding=UTF8]{biblatex}
\usepackage[bottom]{footmisc}
\usepackage{xifthen}
\usepackage{float}
\usepackage{tikz-uml}

\tikzumlset{fill class=white!20, fill template=white!20}

\renewcommand\multinamedelim{\addcomma\space}	%  redefinice oddělování jmén autorů dle ISO690:2011
\renewcommand\finalnamedelim{\addspace\mainsstring{and}\space}

\newcommand{\parspace}[1][]{
	\ifthenelse{\isempty{#1}}{\vspace{5mm}}{\vspace{#1}}
	\par
}

\addbibresource{references.bib}

% remark - poznámka
% definition - definice
% theorem - věta
% example - příklad
% \begin{lstlisting}[label=src:Java,caption=Program v jazyce Java]
% \lstinputlisting[label=src:JavaExternal,caption={Program v jazyce Java, načtený z externího souboru}]{MyClass.java}
% \InsertFigure{Figures/Obr1}{40mm}{Pokusný obrázek -- absolutní velikost}{fig:SampleFigAbs}
% \InsertFigure{Figures/Obr1}{0.7\textwidth}{Pokusný obrázek -- relativní velikost}{fig:SampleFigRel}
% \InsertSidewaysFigure{Figures/Obr1}{0.6\textheight}{Pokusný obrázek -- otočený naležato}{fig:SampleFigSideway}

\ThesisAuthor{Jakub Beránek}
\ThesisTitle{Vizualizace ladění aplikací}
\EnglishThesisTitle{Visualization of application debugging}

\SubmissionDate{29. dubna 2016}

\AccessRestriction{Zde vložte text dohodnutého omezení přístupu k Vaší práci, chránící například firemní know-how.
Zde vložte text dohodnutého omezení přístupu k Vaší práce, chránící například firemní know-how.
A zavazujete se, že\par
\begin{enumerate}
\item o práci nikomu neřeknete,
\item po obhajobě na ni zapomenete a
\item budete popírat její existenci.
\end{enumerate}
A ještě jeden důležitý odstavec. A ještě jeden důležitý odstavec.
A ještě jeden důležitý odstavec. A ještě jeden důležitý odstavec.
A ještě jeden důležitý odstavec. A ještě jeden důležitý odstavec.
Konec textu dohodnutého omezení přístupu k Vaší práci.}

\Thanks{Chtěl bych poděkovat svému vedoucímu, Ing. Marku Běhálkovi, Ph.D., za pomoc a připomínky k tvorbě této práce.}

\CzechAbstract{Tato bakalářská práce se zabývá vizualizací ladění programů napsaných v jazyce C a C++. První část pojednává o
obecných principech ladění programů. %Jsou zde popsány konstrukce, které se při ladění používají, způsob, jakým ladící nástroje
%provádějí ladění programů a také existující ladících nástrojy a jejich grafické nástavby.
Druhá část popisuje běžně používané ladící nástroje a jejich grafické nádstavby.
Třetí část se zabývá implementací grafického nástroje, který vizualizuje pamět a stav procesu během jeho ladění za využití existujících ladících nástrojů  }

\CzechKeywords{ladění programů, vizualizace paměti}

\EnglishAbstract{This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract.}

\EnglishKeywords{typography, \LaTeX, master thesis}

\AddAcronym{API}{Application Programmable Interface}
\AddAcronym{GDB}{The GNU Project Debugger}
\AddAcronym{GNU}{GNU's Not Unix!}
\AddAcronym{GUI}{Graphical user interface}
\AddAcronym{IPC}{Inter-process communication}
\AddAcronym{JSON}{JavaScript Object Notation}

% Zadame cestu a jmeno souboru ci nekolika souboru s digitalizovanou podobou zadani prace
% Pri sazbe se pak hledaji soubory Figures/Zadani1.jpg, Figures/Zadani2.jpg atd.
% Do diplomove prace se postupne vlozi vsechny existujici soubory Figures/ZadaniXXX.jpg
% Pokud toto makro zapoznamkujeme sazi se stranka s upozornenim
\ThesisAssignmentImagePath{Figures/Zadani}

% Zadame soubor s digitalizovanou podobou prohlaseni
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni
\DeclarationImageFile{Figures/Prohlaseni.jpg}

% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
\listoftables
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
\listoffigures
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
\lstlistoflistings
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Zacneme uvodem
\begin{section}{Úvod}
	Jazyky C a C++ jsou velmi komplexní a dovolují programátorům pracovat s hardwarem počítače na značně nízké úrovni. Kvůli mnohým vlastnostem,
	jako je absence automatické správy paměti nebo možnost provádět potencionálně nebezpečné operace s paměťovými ukazateli, jsou velmi náchylné ke vzniku
	těžko odhalitelných chyb. Používání ladícího nástroje, který dokáže detailně zkoumat paměť běžícího procesu a krokovat ho, je tedy v těchto jazycích nutností,
	bez které by byl vývoj C a C++ aplikací výrazně pomalejší.

	\parspace Ladění tedy je nezbytná součást vývoje programů, která dovoluje programátorům detailně sledovat a ovládat laděný proces, aby v něm mohli odhalit
	chyby a lépe pochopit jeho průběh. Ladící nástroje vytváří asociaci mezi zdrojovým kódem a binárním spustitelným
	souborem a poskytují tak tvůrci kódu možnost ladit kód na vysoké úrovni abstrakce, tj. na úrovni samotného zdrojového kódu.
	Existující nástroje, jako je GDB nebo LLDB, mají velké množství užitečných funkcí, ale samy o sobě poskytují svému uživateli pouze ladění
	pomocí terminálu. To je pro velké programy velmi pomalé a nepřehledné řešení. Nad těmito nástroji proto vznikla různá grafické rozšíření,
	ať už samostatná nebo integrovaná v komplexních vývojových prostředích. Tato uživatelská rozhraní umožňují mnohem pohodlnější a jednodušší ladění programů.
	Díky tomu může být ladění přirozenou součástí vývoje programů, a ne pouze obtížnou činností nutnou při hledání skrytých chyb.
	
	\parspace I když grafické uživatelské rozhraní ladění značně usnadňuje, tak reprezentace paměti se v něm většinou omezuje na pouhý textový výpis názvů proměnných
	a jejich hodnot. To postačuje pro hledání chyb v programu, ale nedovoluje to plně zobrazit vztahy mezi objekty a jejich umístění v paměti.
	Zobrazení grafické reprezentace objektů v paměti může být také užitečné pro pochopení a sledování průběhu určitých (např. třídících) algoritmů.
	Cílem této práce je vývoj grafického rozhraní, které bude umožňovat vizualizaci laděného programu pro lepší pochopení jeho vnitřního stavu a bude také nezávislé
	na použitém ladícím programu.	

	\parspace Kapitola \ref{sec:DebuggingPrinciples} popisuje obecné principy ladění, které jsou společné pro všechny ladící programy. Vysvětluje také terminologii
	potřebnou pro pochopení dalšího textu. Po ní následuje kapitola \ref{sec:ExistingDebuggers}, pojednávající o existujících
	ladících programech a jejich grafických rozhraních. Kapitola \ref{sec:DeviImplementation} se poté věnuje návrhu a vývoji vizualizační aplikace a
	komunikačního rozhraní pro přístup k ladícím nástrojům.
	
	\parspace Tato práce je zaměřená na programy pro operační systémy založené na Linuxovém jádře. Pojmem Linuxový systém se v této práci myslí
	libovolná distribuce Linuxu. Pro označení programů, které umožňují ladění jiných programů, je v této práci používán termín debugger,
	jelikož se jedná o často používaný programátorský termín a v češtině pro něj neexistuje zavedená alternativa.
\end{section}
\begin{section}{Principy ladění programů}
\label{sec:DebuggingPrinciples}
	Tato kapitola popisuje obecné principy fungování ladících nástrojů, způsob mapování binárních instrukcí programu zpět do jeho zdrojového kódu,
	krokování běžícího procesu a běžné konstrukce používané při ladění. Konkrétně je popis zaměřen na programy napsané v jazycích C a C++
	v prostředí Linuxových systémů používající procesory z rodiny Intel x86. %TODO: důvod?%
	Popsané principy jsou ale obecné a lze je aplikovat na libovolný operační systém.
		
	\subsection{Signály}
		Pro ladění programu je nutné mít možnost číst jeho paměť, aby šly zkoumat hodnoty proměnných za jeho běhu, a také ho zastavit, jelikož
		programy za běhu provádějí obrovské množství instrukcí za vteřinu a zkoumat takto rychle se měnící datový tok by bylo obtížné.
		Aby šlo proces zastavit, musí mu jiný proces anebo sám operační systém zaslat signál.
		Signály jsou zprávy, které lze zaslat běžícímu procesu, ten si je může odchytit a zareagovat na ně.\cite[21]{tanenbaum}
		Slouží pro meziprocesní komunikaci a fungují jako softwarová obdoba hardwarových přerušení procesoru.
		Jakmile proces obdrží signál, který očekává, tak si uloží hodnoty svých registrů a přejde do procedury, která tento signál obslouží.
		Pokud proces obdrží signál, pro který si nepřipravil žádnou reakci, tak se provede implicitně nadefinovaná akce pro daný typ signálu.
		V Linuxových systémech je definováno několik desítek standardních signálů, v závislosti na verzi a typu operačního systému.
		Na signály SIGKILL, sloužící k okamžitému ukončení procesu a SIGSTOP, sloužící k zastavení procesu, nemá proces možnost zareagovat ani
		zjistit, že mu byly poslány.
	
	\subsection{Krokování}
		Operační systémy obvykle poskytují nástroj, pomocí kterého lze buď spustit proces, anebo se připojit k již běžícímu procesu, a následně ho ovládat
		a přistupovat k jeho paměti. Linuxové systémy pro tento účel poskytují systémové volání \textbf{ptrace}\footnote{http://linux.die.net/man/2/ptrace},
		které umožňuje zachytávat signály zaslané sledovanému procesu. Proces sledovaný pomocí funkce ptrace je zastaven při přijetí jakéhokoliv signálu
		(kromě signálu SIGKILL, který se pokusí proces okamžitě ukončit). Tohoto mechanismu využívají ladící nástroje, které proces sledovaný pomocí
		ptrace můžou po jeho zastavení znovu spustit, přistupovat k jeho paměti a ovlivňovat jeho průběh. Pokud je sledovaný proces potomkem procesu,
		který ho sleduje, bude při jeho spuštění vyvolán signál SIGTRAP, který dovolí rodičovi odchytit začátek provádění potomka. Jakmile je proces
		zastavený, může ho ladící nástroj tzv. krokovat, tedy spouštět instrukci po instrukci. K tomu lze použít funkci ptrace s příznakem PTRACE\_SINGLESTEP,
		která provede přesně jednu instrukci v laděném procesu (proces se také zastaví, pokud se dostane na vstupní nebo výstupní bod systémového volání).
		Ladící nástroje obvykle nabízí krokování na vyšší úrovni než pouze po jedné instrukci, jelikož to by bylo zbytečně zdlouhavé (u vyšších programovacích
		jazyků se jeden řádek zdrojového kódu může mapovat na desítky až stovky instrukcí). Obvykle jsou dostupné následující krokovací akce:
		\begin{description}
			\item[Krok po řádku] - program se obnoví, provede instrukce odpovídající jednomu řádku zdrojového kódu a poté se opět zastaví
			\item[Krok dovnitř funkce] - funguje stejně jako krok po řádku, ale program se zastaví i při zavolání funkce
			\item[Krok ven z funkce] - program bude pokračovat, dokud neskončí funkce, ve které se právě nachází
		\end{description}
		
	\subsection{Obousměrné mapování zdrojového kódu na instrukce}
		Aby mohly ladící nástroje nabízet krokování na úrovni (řádků) zdrojového kódu, musí umět namapovat zdrojový kód na instrukce vygenerovaného
		spustitelného programu i instrukce zpět na zdrojový kód. Jelikož programy psané v jazycích C a C++ jsou kompilované a po jejich překladu nejsou
		ve výsledném binárním souboru téměř žádné informace o jejich zdrojovém kódu, musí být přeloženy ve speciálním režimu, který při překladu vygeneruje
		metadata s mapováním zdrojového kódu a vloží je do přeloženého programu. V překladačích jazyka C/C++ se tohoto dá standardně dosáhnout použitím
		řepínače \textbf{-g}. Existuje několik formátů ukládání těchto metadat, dnešním de facto standardem na Linuxových systémech je DWARF
		\footnote{http://dwarfstd.org}. Ten ukládá proměnné, datové typy, procedury a další údaje ze zdrojového kódu ve stromové struktuře.
		Pro ušetření místa obsahuje instrukce pro speciální konečný automat, který implementují ladící nástroje a pomocí něho poté získávají
		informace o původním zdrojovém kódu.
		
		\parspace Samotné mapování zdrojového kódu není pro ladící nástroj užitečné, pokud je výsledný program zoptimalizovaný překladačem. Po optimalizaci
		totiž program nemusí obsahovat všechny původní proměnné, funkce a jeho průběh ani nemusí přesně odpovídat jeho zdrojovému kódu. Při použité málo agresivní
		optimalizace někdy lze programy úspěšně ladit, ale pro zajištění co nejpřesnějšího ladění programů je obvykle nutné optimalizace úplně vypnout. Toho lze
		v překladačích obvykle dosáhnout použitím přepínače \textbf{-O0}.
	
	\subsection{Běžné konstrukce ladících nástrojů}
		\begin{description}
			\item[Breakpoint]
				Většina ladících nástrojů poskytuje svým uživatelům možnost zastavit běh laděného procesu pomocí tzv. breakpointu.
				Jedná se o označení řádku v zdrojovém kódu programu, na kterém se program za běhu zastaví a umožní tak uživateli prozkoumat paměť procesu a krokovat ho.
				Nejčastěji je implementován tak, že ladící nástroj nejdříve zjistí z daného řádku adresu instrukce ve vygenerovaném spustitelném souboru, kterou tento
				řádek představuje, uloží si ji a nahradí ji instrukcí přerušení s kódem 3. Toto přerušení je určeno speciálně pro ladění procesů, jelikož generuje
				instrukci o velikosti jednoho bytu, a lze jím tak nahradit libovolnou instrukci\cite[306]{intel}. Pokud by měla více než jeden byte, mohlo by ses
				stát, že by tato instrukce přepsala více než jednu instrukci, což by mohlo způsobit nevalidní chování programu. Jakmile program během svého běhu
				provede tuto instrukci, vyvolá se signál SIGTRAP, který ladící nástroj odchytí a laděný proces se tímto zastaví. Pokud se uživatel rozhodne proces
				opět sputit, ladící nástroj zkopíruje původní instrukci programu (kterou si dříve uložil) na místo, kde vložil přerušení, nastaví na ni ukazatel
				příští instrukce a proces opět spustí.
				Některé procesory nabízí také hardwarový breakpoint, který sice může být rychlejší, ale obvykle kvůli tomu, že je implementován v hardwaru, tak poskytuje
				vytvoření pouze několika breakpointů zároveň.
			\item[Tracepoint]
				V některých případech není možné laděný proces pozastavit k prozkoumání jeho paměti, jelikož jeho průběh může záviset na reálně uběhlém čase a zastavení
				tedy může způsobit, že program neproběhne korektně. Pro tyto situace lze použít tracepoint, u kterého se uvede lokace v programu a paměť, která má být
				sledována. Pokaždé, když se laděný proces dostane na tuto lokaci, tak je uložena sledovaná paměť a po skončení běhu procesu si lze zpětně prohlédnout,
				jak se tato paměť v průběhu programu měnila.
			\item[Watchpoint]
				Pokud je potřeba zastavit program ne na konkrétním místě, ale při změně dané hodnoty v paměti, lze použít watchpoint. Ten se může hodit například pro
				kontrolu změn globálních proměnných. Pokud nenabízí procesor hardwarovou podporu pro watchpointy, ladící nástroj prochází laděný proces instrukci po
				instrukci, testuje hodnotu sledované paměti a pokud se tato hodnota změní, tak program zastaví. Tento proces může zpomalit laděný proces až o
				dva řády\footnote{https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html}.
			\item[Catchpoint]
				Tuto konstrukci lze použít pro zachycení událostí procesu, jako jsou načtení sdílené knihovny, vyvolání hardwarové či softwarové výjimky, provedení
				systémového volání anebo přijetí signálu. Většina těchto událostí je ze své podstaty asynchronní, nelze u nich tedy dopředu určit, kdy budou zavolány
				a použití breakpointu tedy není možné.
		\end{description}
\end{section}
\begin{section}{Existující ladící nástroje}
\label{sec:ExistingDebuggers}
	Ladících nástrojů pro jazyky C a C++ existuje velké množství, v této kapitole jsou popsány dva z nejpoužívanějších nástrojů, GDB a LLDB, které byly dále
	použity při implementaci vizualizačního nástroje. Jsou zde taky popsány jejich vybrané grafické nádstavby.

	\subsection{GDB}
		GDB (The GNU Debugger) je standardním ladícím nástrojem pro Linuxové systémy, často je v těchto systémech už předinstalovaný.
		Jeho hlavním zaměřením je ladění programů napsaných v jazycích C a C++, ale podporuje mimo jiné i Adu, Objective-C, Pascal, Fortran, Javu
		a Go\cite{gdb-languages}. Podporuje velké množství rodin procesorů, například ARM, AVR, Itanium, MIPS, PowerPC, SPARC a samozřejmě x86 i x86-64.
		Lze jej spustit i na platformě Windows pomocí prostředí emulujících Linux, jako je Cygwin nebo MinGW. Byl vydán v roce 1986 a k roku
		2016 stále vycházejí nové verze.
		
		\par Umí spolupracovat s programy přeloženými libovolným překladačem jazyků C a C++, pokud je dodržen jejich standard. Navíc ještě obsahuje
		speciální podporu pro překladač GCC (GNU Compiler Collection), který pro něj umí vygenerovat dodatečná ladící metadata.
		GDB obsahuje základní funkce nezbytné pro každý ladící nástroj, jako je načtení ladících metadat v mnoha formátech (podporuje DWARF i několik dalších
		formátů), vytváření breakpointů, tracepointů a watchpointů, krokování programu a čtení i zápis paměti programu.
		Mimo to ale nabízí i pokročilé funkce, které ovšem nemusí být podporované všemi procesory a platformami, s kterými GDB jinak umí pracovat.
		
		\begin{description}
			\item[Vzdálené ladění]
				GDB dokáže být spuštěn na jednom zařízení a ladit program spuštěný na jiném zařízení pomocí síťové komunikace (obvykle pomocí protokolu TCP).
				Toto může být užitečné, pokud není dostupný fyzický přístup k systému, který je potřeba odladit.
				Vzdálené ladění se dá využít také k ladění jádra (kernelů) operačního systému, čehož je využito například v programu KGDB, který se používá k ladění
				jader operačních systémů Linux a FreeBSD pomocí sériového připojení.
			\item[Ladění vícevláknových aplikací]
				Pokud GDB ladí program, který využívá více než jedno vlákno, může pracovat v několika rozlišných módech\cite{gdb-multithreading}.
				V All-stop módu se při zastavení jednoho vlákna zastaví také všechna ostatní vlákna, aby šlo mezi vlákny přepínat a číst jejich paměť bez toho,
				aby se paměť mezitím nějak změnila. Pokud je nutné zastavit pouze jedno vlákno, tak, aby ostatní pokračovala v běhu, lze použít tzv. Non-stop mód,
				který vždy zastaví pouze vlákno, které narazí na breakpoint, a zbytek vláken nechá běžet. S tímto módem je vhodné použít asynchronní ovládání GDB,
				pomocí kterého lze zasílat ladící příkazy programu i za jeho běhu a ovládat tak pouze zastavené vlákno, i když zbytek vláken stále běží.
			\item[Provádění výrazů]
				Pomocí GDB lze nejenom číst a zapisovat paměť laděného procesu na úrovni bytů v adresním prostoru procesu, ale v podporovaných jazycích, hlavně
				v C a C++, lze také provádět libovolné jazykové výrazy, volat funkce programu a systémová volání a pracovat s hodnotami na úrovni proměnných
				laděného programu.
			\item[Spolupráce s Valgrindem]
				Valgrind je nástroj pro profilování a kontrolu paměťové korektnosti programů, který se využívá k hledání paměťových chyb, jako je například memory
				leak. Vytváří virtuální stroj, ve kterém spouští zkoumaný program a kvůli této vlastnosti jej nelze ladit klasickými přístupy. GDB poskytuje
				možnost připojit se k programu spuštěnému ve Valgrindu a vzdáleně ho takto ladit.
			\item[Analýza logu z ukončeného procesu]
				Procesy, které se ukončí s chybou, např. po vyvolání výjimky, můžou vygenerovat výpis paměti (core dump), který lze poté načíst v GDB a zanalyzovat ho.
				Lze tak například zobrazit stav zásobníku volání funkcí v momentu, kdy program zhavaroval, a zjistit tak, který kód programu způsobuje chybu.
			\item[Zpětné provádění instrukcí]
				Při ladění nastává často situace, kdy proces zajde moc daleko a přeskočí instrukci, kterou chce uživatel zkoumat. GDB umí spouštět určité instrukce
				zpětně, a může tedy krokovat program nejenom dopředu, ale i dozadu. Všechny změny a vedlejší efekty, které proběhly v paměti, jsou tak smazány a
				navráceny do původního stavu (pokud to daná platforma a stav programu dovoluje).
		\end{description}
		
		GDB nemá vlastní grafické rozhraní, je ovládán z příkazové řádky. Kromě toho ale podporuje také spouštění skriptů v Pythonu pomocí API,
		které bylo použito pro implementaci vizualizačního nástroje a je popsáno dále v textu.
	\subsection{LLDB}
		Ladící nástroj LLDB\footnote{http://lldb.llvm.org} je založen na sadě knihoven, které využívají infrastruktury LLVM a překladače Clang.
		LLVM je univerzální překladače, který dokáže překládat velké množství jazyků do své vnitřní, jazykově nezávislé reprezentace, kterou umí
		optimalizovat a vygenerovat z ní dále spustitelný soubor pro libovolnou kompatibilní platformu. Obsahuje také kompletní implementaci standardní
		knihovny jazyka C++, která plně podporuje jeho nejnovější standard, C++11. Clang je nádstavbou LLVM, která analyzuje a překládá programy v jazyce
		C a C++. Celá LLVM architektura je postavena na modulárních komponentech, které spolupracují a dají se lehce využít ve formě knihovny.
		Nabízí tak modernější alternativu k programům GCC a GDB. Ty jsou sice stabilnější a prověřenější, ale jelikož existují už desítky let a musí udržovat
		zpětnou kompatibilitu, tak je těžší je využít jako modul do jiného programu. Z tohoto důvodu rovněž pomaleji přecházejí k novým standardům.
		
		\parspace Umí ladit programy napsané v jazycích C, C++, Objective-C a Swift na platformách OS X, Linux, Free BSD a Window. Podporuje tedy méně jazyků
		i platforem, než GDB, ale narozdíl od něho je podporován, a stal se také standardním ladícím nástrojem, i operačními systémy OS X a iOS.
		Nabízí většinu standardních funkcí ladících nástrojů, jako je krokování kódu, vytváření breakpointů a čtení a zápis paměti procesu.
		Jelikož je stále ve vývoji, tak zatím neobsahuje některé pokročilejší funkce, které nabízí GDB, například zpětné provádění instrukcí.

	\subsection{Grafická rozhraní}
		Grafických rozhraní pro debuggery GDB a LLDB existuje několik desítek. Některé z nich jsou samostatné programy podporující pouze ladění, další jsou
		jednou z mnoha součástí integrovaných vývojových prostředí. Rozhraní těchto nástrojů se obvykle skládá z textového editoru, který obsahuje zdrojový kód,
		ovládacích prvků, které kontrolují průběh laděného procesu. Dále také často nabízí manipulaci a zobrazování registrů, lokálních proměnných a parametrů
		funkcí. Ukázky uživatelského rozhraní jednotlivých programů si lze prohlédnout v příloze \ref{appendix:gui}. Následuje popis jednoho zástupce
		ze skupiny samostatných (DDD), integrovaných (Clion) a textových (TUI) uživatelského rozhraní pro ladění programů.
	
		\begin{description}
			\item[TUI]
				Text User Interface je grafickým rozhraním vestavěným přímo v GDB, které zobrazuje stav průběhu v několik terminálových oknech pro větší přehlednost
				programu. Je postaveno na knihovně curses, která umožňuje vytvářet textové uživatelské rozhraní s pokročilými funkcemi přímo v terminálu. TUI lze
				spustit předáním parametru \textbf{-tui} při spouštění GDB anebo stisknutím kláves CTRL+X či spuštěním příkazu \emph{tui enable} za jeho běhu.
				LLDB obsahuje podobné rozhraní také, ale není zatím oficiální součástí nástroje, jedná se pouze o nezávazně vyvíjený doplněk.
			\item[DDD]
				DDD, neboli Data Display Debugger, je grafické prostředí podporující velké množství ladících nástrojů, mimo jiné GDB, pydb, DBX nebo Ladebug.
				Mimo klasického zobrazování zdrojového kódu programu nabízí i pokročilé vizualizační funkce. Umí kreslit grafy z hodnot paměti procesu
				anebo zobrazovat vztahy mezi objekty v paměti ve formě grafu. Jeho poslední verze vyšla v roce 2009, není už tedy v současnosti aktivně udržován.		
			\item[Clion]
				Clion je integrované vývojové prostředí založené na vývojové platformě IntelliJ. Nabízí mimo jiné statickou analýzu kódu psaného v jazycích
				C a C++, což pomáhá v odhalování velkého množství chyb již během psaní programu. Tato analýza zároveň usnadňuje ladění kódu poskytováním
				automatického doplňování výrazů a proměnných, které lze v laděném procesu sledovat. Během ladění Clion zobrazuje vedle názvů proměnných
				ve zdrojovém kódu jejich současnou hodnotu, což velmi urychluje pochopení stavu výpočtu.
		\end{description}

\end{section}
\begin{section}{Implementace vizualizačního nástroje}
\label{sec:DeviImplementation}
  Cílem této práce bylo navrhnout a naimplementovat program, který bude ladění programu vizualizovat ve formě grafu objektů v paměti, a otestovat,
	jestli tato grafická reprezentace usnadňuje ladění programů a pochopení průběhu jednoduchých algoritmů.
	Tato kapitola pojednává o návrhu a implementaci tohoto nástroje, spolu s implementací knihovny pro komunikaci s debuggery.
	Vizualizační nástroj jsem pojmenoval a dále jej v textu budu označovat jako \textit{Devi}.
	
	\subsection{Specifikace požadavků}
	Program by měl existovat jako klasická GUI aplikace s okny. Jeho hlavní funkcí by mělo být vizualizovat stav laděného procesu zobrazováním části jeho
	adresního prostoru. Zobrazovat by měl hlavně zásobník, který představuje současný stav a pozici procesu a z hlediska ladění se jedná o první místo,
	kde lze začít hledat chyby.
	Aby se dal program použít pro ladění reálně používaných aplikací, měl by poskytovat přístup ke všem běžným
	funkcím debuggerů. Měl by také být nezávislý na použitém debuggeru. Následuje seznam základních funkcí, které by měl program svým uživatelům nabízet.
	
	\begin{itemize}
		\item Asynchronní komunikace s debuggerem
		\item Načítání binárních i zdrojových souborů
		\item Zobrazování zdrojového i strojového kódu programu
		\item Vytváření a odebírání breakpointů
		\item Manipulace s procesem (spuštění, pozastavení, zastavení)
		\item Krokování (krok po řádku, krok dovnitř funkce, krok ven z funkce)
		\item Komunikace s procesem v reálném čase (přes standardní vstup a výstup)
		\item Přepínání zásobníkových rámců
		\item Přepínání vláken
		\item Zobrazování registrů a paměti na úrovni bytů
		\item Manipulace s hodnotami proměnných
		\item Vizualizace objektů v paměti ve formě grafu
	\end{itemize}
	
	\subsection{Architektura}
	\par Pro implementaci programu jsem zvolil programovací jazyk \textbf{Python}\footnote{http://www.python.org} ve verzi 2.7. Novější verze 3.x nebyla použita
	z důvodu zachování kompatibility s již existujícími API pro debuggery, které v době tvorby této práce Python 3 ještě zcela nepodporovaly. Pro případnou
	budoucí konverzi do Pythonu 3 lze použít automatizované nástroje, například \textbf{2to3} \footnote{https://docs.python.org/2/library/2to3.html}.
	Python jsem vybral, protože je vhodný k rychlému vývoji aplikací, existuje pro něj několik rozhraní pracujících s debuggery a umí snadno používat
	kód napsaný v jazycích C a C++. Navíc je multiplatformní, což by usnadnilo případný port aplikace na jiný operační systém.
	
	\parspace Pro vývoj grafického rozhraní programu jsem vybral knihovnu \textbf{GTK+ 3}\footnote{http://www.gtk.org}. Jedná se o volně dostupný
	\footnote{Pod licencí LGPL 2.1}, multiplatformní grafický software umožňující tvorbu uživatelského rozhraní, který je používán mimo jiné i
	některými manažery plochy pro Linux (např. v GNOME\footnote{https://www.gnome.org/technologies}). Kromě možnosti tvorby vlastních
	GUI prvků obsahuje několik desítek běžně používaných prvků, které jsou předpřipravené k okamžitému použití a usnadňují tak rychlý vývoj aplikací.
	
	\parspace Nástroj je tvořen dvěmi samostatnými komponentami, aplikací s grafickým rozhraním, která slouží k vizualizaci a k interakci s laděným procesem,
	a knihovny, která poskytuje rozhraní pro komunikaci s libovolným debuggerem. Obrázek \ref{fig:DeviArchitecture} zachycuje pohled na architekturu aplikace
	z vysoké úrovně.
	Uživatelské rozhraní komunikuje s knihovnou, která zprostředkovává komunikaci s debuggerem. Na obrázku jsou zobrazeny tři implementace této komunikační vrstvy,
	které jsou popsány dále v textu. Debugger zajišťuje komunikaci a manipulaci s laděným procesem. Celá aplikace je tak rozdělena do několika
	vrstev, které jsou na sobě nezávislé.
	
	\InsertFigure{Figures/bak_architektura}{\textwidth}{Architektura programu \textit{Devi}}{fig:DeviArchitecture}
		
	\subsection{Knihovna pro komunikaci s debuggery}
		Tato knihovna tvoří rozhraní pro komunikaci s libovolným ladícím nástrojem. Definuje abstraktní typy popisující laděný proces a není tak závislá na
		použitém ladícím nástroji. Není nijak závislá ani na grafickém rozhraní nástroje, lze ji tedy použít pro programovatelné ovládání debuggerů i v jiném
		projektu. Knihovna obsahuje třídy představující části laděného procesu, které jsou dostatečně obecné na to, aby se daly aplikovat na libovolný
		proces i debugger. Následuje popis těchto typů.
		
		\begin{description}
			\item[Type] představuje datový typ proměnné, obsahuje jeho název, kategorii a velikost
			\item[Variable] představuje proměnnou, obsahuje její název, datový typ, adresu v paměti, hodnotu a potomky
			\item[Frame] představuje rámec zásobníku, obsahuje jeho úroveň v zásobníku a název a lokaci funkce, z které je vyvolán % TODO
			\item[InferiorThread] představuje vlákno procesu, obsahuje jeho identifikátor, název, stav a současný zásobníkový rámec
			\item[ThreadInfo] uchovává seznam všech vláken v procesu a také současně zvolené vlákno
			\item[Breakpoint] představuje breakpoint, obsahuje jeho identifikátor a zdrojový soubor a řádek, na kterém je umístěn
			\item[Register] představuje registr procesoru, obsahuje jeho název a hodnotu
			\item[HeaBlock] představuje blok paměti naalokované na haldě, obsahuje adresu a velikost v bytech
		\end{description}
		
		\parspace Dále jsou v knihovně třídy, které tvoří obecné API pro přístup k debuggeru. Slouží jako rodičovské třídy pro jednotlivé implementace
		komunikace s debuggerem. Jejich smyslem není implementovat společné chování, jelikož jednotlivé debuggery a implementace přístupu k nim
		se od sebe můžou značně lišit, a tak poskytují pouze rozhraní. Následuje seznam tříd tohoto rozhraní.
		
		\begin{description}
			\item[Debugger] představuje abstrakci ladícího nástroje, který umožňuje načtení binárního souboru programu, jeho spuštění, zastavení
			a krokování. Dále také uchovává stav laděného procesu a obsahuje všechny ostatní komponenty rozhraní vyjmenované níže.
			\item[VariableManager] se stará o čtení registrů a paměti procesu a o získávání a změnu jeho proměnných
			\item[ThreadManager] se stará o získávání a volbu vláken a zásobníkových rámců
			\item[FileManager] se stará o získávání současné pozice a hlavního souboru laděného procesu. Poskytuje také převod zdrojového kódu
			na strojový kód.
			\item[BreakpointManager] se stará o přidávání, mazání a načítání breakpointů
			\item[IOManager] se stará o komunikaci s laděným procesem pomocí čtení z jeho standardního a chybového výstupu a zápisu do jeho standardního vstupu
		\end{description}
		
		Pro účely této práce jsem v této knihovně vytvořil a otestoval několik implementací pro komunikaci s GDB a LLDB.

		\subsubsection{Python API pro GDB}
		GDB obsahuje rozhraní \footnote{https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html}, které nabízí možnost načtení skriptů v Pythonu 2, které
		můžou ovládat GDB a přistupovat k jeho vnitřním funkcím. Většina nejpoužívanějších funkcí GDB je tak dostupná ve formě tříd a funkcí.
		Funkce GDB, které v API nejsou obsaženy, lze vyvolat pomocí přímého provádění textových příkazů.
		Nevýhoda tohoto přístupu je, že toto API neumí samo spustit instanci GDB a musí tak být načteno v již běžícím GDB procesu.
		Nelze jej tedy použít přímo v kódu jiné aplikace bez použití IPC. Tento problém jsem vyřešil TCP komunikací se skriptem běžícím
		v procesu GDB. Jelikož je ale toto řešení komplikovanější než ostatní způsoby práce s GDB a při testování
		nebylo stabilní, tak jsem jeho implementaci nadále nerozšiřoval.
		
		\subsubsection{Python API pro LLDB}
		Stejně jako GDB, i LLDB poskytuje API v Pythonu. Lze jej načíst do procesu LLDB a automatizovat tak průběh ladění, stejně jako u dříve zmíněného GDB
		rozhraní. Navíc jej ale lze také použít jako knihovnu, která sama vytváří instanci LLDB a je tedy jednoduché ji použít přímo v externím kódu.
		Pomocí tohoto API jsem vytvořil komunikační vrstvu, která implementuje většinu potřebných funkcí pro tvorbu vizualizačního nástroje.
		Nicméně stejně jako celé LLDB je toto API zatím ve vývoji a obsahuje drobné chyby, například nepřesné zobrazování stavu vláken. Kvůli těmto nedostatkům
		jsem do této implementace nepřidával podporu ladění vícevláknových aplikací.
		
		\subsubsection{Protokol GDB MI}
		MI je protokol pro ovládání GDB pomocí textových příkazů, které jsou narozdíl od klasických příkazů používaných při manuálním ovládání debuggeru
		přizpůsobené pro jednoduché strojové zpracování. Obdobně jako Python API pro GDB poskytuje MI rozhraní pouze pro nejpoužívanější funkce.
		Zbytek funkcí lze používat pomocí běžných textových příkazů. Použití MI je běžným a doporučeným \cite{gdb-mi-usage} způsobem pro programovou komunikaci
		s GDB a tvorbu grafických rozhraní. Existují volně dostupné knihovny pro Python i C/C++, které umí komunikovat pomocí MI protokolu, nicméně za
		účelem pochopení fungování tohoto protokolu a možnosti přizpůsobení komunikace jsem vytvořil vlastní komunikační modul, který je popsán dále v textu.
		
		\begin{description}
			\item[Komunikace s debuggerem]
			Aby GDB umělo komunikovat pomocí MI, tak se nejprve musí přepnout do MI módu, což lze pomocí parametru předaného při spuštění. V tomto módu
			lze na jeho standardní vstup zaslat textové zprávy, které se vyhodnotí a vrátí výsledek. Formát zpráv je jasně daný speficikací
			\footnote{https://sourceware.org/gdb/onlinedocs/gdb/GDB\_002fMI-Command-Syntax.html} a je přizpůsoben strojovému zpracování. Zprávy z debuggeru
			vždy obsahují hlavičku, která určuje, o jaký typ zprávy jde, a tělo, které obsahuje případné další informace o vyvolané události nebo
			provedeném příkazu. Struktura MI zpráv velmi podobná syntaxi zpráv ve formátu JSON\footnote{http://www.json.org}, který je v současné době standardním
			formátem pro výměnu dat a existuje pro něj velké množství parserů.
			Rozhodl jsem se tedy tyto zprávy nejprve předzpracovat a poté je zpracovat JSON parserem, který poskytuje
			standardní knihovna Pythonu. % TODO: psát, že jsem si to ulehčil?
			Po odeslání příkazu knihovna čeká, než jí přijde odpověď, která musí následovat po každém příkazu.
			
			\parspace Kromě této synchronní komunikace (zaslání příkazu - přijetí odpovědi) posílá GDB také zprávy o asynchronních událostech, jako je např.
			vytvoření vlákna nebo zastavení procesu. Grafické rozhraní debuggeru musí na tyto zprávy reagovat ihned poté, co jsou debuggerem zaslány.
			Kvůli toho se v komunikačním modulu vytváří samostatné vlákno, které v pravidelném časovém intervalu kontroluje výstup z debuggeru a pokud zjistí, že došlo
			k asynchronní události, tak vyvolá vlastní událost, ke které se může přihlásit libovolný klient. Při tomto periodickém čtení může dojít k souběhu, pokud
			by během čtení přišel od klienta knihovny požadavek na odeslání příkazu, který se také snaží číst výstup z GDB při čekání na svou odpověď.
			% TODO: vysvětlit, co je souběh, mutex?
			Z tohoto důvodu je čtení výstupu debuggeru zamknuto mutexem, který potencionální souběh vylučuje.
			
			\parspace Některé funkce knihovny jsou naimplementované jinak než zasláním textového příkazu do GDB, například přerušení programu, které
			slouží k zastavení programu v libovolnou chvíli. Přerušení je vyvoláno tak, že se procesu zašle signál SIGINT, který vyvolá zastavení procesu v GDB a to
			už je následně zpracováno knihovnou standardně, jako by se jednalo o zastavení při breakpointu. Stejně tak násilné ukončení programu ho nejprve přeruší,
			a teprve poté pošle GDB příkaz k ukončení laděného procesu.
			
			\item[Komunikace s laděným procesem]
			MI implicitně přesměrovává veškerý výstup z laděného procesu na svůj vlastní výstup. Toto chování není moc užitečné, jelikož se výstup a vstup laděného
			procesu mísí s vstupem a výstupem samotného ovládání GDB. Pro vyřešení tohoto problému lze v GDB pomocí příkazu \textit{-inferior-tty-set}
			\footnote{https://sourceware.org/gdb/onlinedocs/gdb/GDB\_002fMI-Miscellaneous-Commands.html} nastavit terminál, s kterým bude laděný proces komunikovat.
			Při použití tohoto řešení se mi nepovedlo komunikovat s procesem v reálném čase kvůli vnitřnímu bufferování terminálu a problému s čtením z terminálu z
			jiného vlákna. % TODO: dát pryč předchozí větu?
			Rozhodl jsem se tedy použít třetí řešení, které při komunikaci s laděným procesem naprosto obchází GDB.
			% TODO: vložit obrázek s nákresem I/O komunikace
			
			\parspace Před zapnutím laděného procesu se v systémové složce pro dočasná data vytvoří čtyři speciální soubory, jeden pro vstup, dva pro výstup
			(klasický a chybový) a jeden pro alokace, které jsou popsány dále v textu. Komunikace se soubory je znázorněna na obrázku \ref{fig:DebugeeIO}.
			Tyto soubory jsou vytvořeny pomocí systémového volání \textit{mkfifo}\footnote{http://linux.die.net/man/3/mkfifo}, které vytváří pojmenovanou rouru
			% TODO: roura?
			reprezentovanou souborem. Takto vytvořené soubory lze poté otevřít pro čtení nebo zápis. Narozdíl od klasických souborů ale musí být tato pípa otevřená na
			obou svých koncích zároveň. Pokud se tedy nějaký proces pokusí otevřít pípu pro čtení, bude zablokován, dokud se nějaký jiný proces nepokusí otevřít danou
			pípu pro čtení. Obsah pípy není uložen na souborovém disku, ale je v paměti, lze tak pomocí ní komunikovat v reálném čase mezi procesy, což jsem využil
			pro komunikace s laděným procesem. Na straně knihovny se vytvoří vlákno, které tyto soubory otevře a neustále z nich čte data. Umí také laděnému procesu
			zaslat data na jeho standardní vstup. Při zapnutí laděného procesu v GDB je poté jeho standardní výstup i vstup přesměrován do těchto souborů pomocí
			standardního přesměrování vstupu a výstupu ze shellu. % TODO: co je shell?
			Po ukočení laděného procesu se poté tyto dočasné soubory smažou.
			
			\item[Detekce dynamických alokací]
			\textit{Devi} sleduje dynamické alokace paměti na haldě laděného procesu, aby mohl zobrazovat stav adresního prostoru procesu a upozorňovat na některé
			chyby způsobené špatnou prací s pamětí. Systémová knihovna jazyka C obsahuje implementaci alokátoru, který se stará o alokaci a dealokaci paměťových
			bloků na haldě. Pro tuto práci s dynamickou pamětí se v jazyce C používají funkce \textbf{malloc}, \textbf{calloc}, \textbf{realloc}
			a \textbf{free}. V jazyce C++ se používají operátory \textbf{new} a \textbf{delete}, které ovšem také vnitřně volají již zmíněné C funkce, takže není
			nutné je explicitně zaznamenávat. Aby šlo sledovat alokace, je nutné zachytit volání všech funkcí pracujících s dynamickou pamětí a zaznamenat si
			jejich parametry a návratové hodnoty. Zachycení volání těchto funkcí lze zajistit různými způsoby. Já jsem si určil jako podmínkou to, aby šlo pracovat
			přímo se spustitelným souborem a nebyla vyžadována úprava zdrojového kódu programu.
			Nutnost úpravy zdrojového kódu by totiž byla nepraktická u větších programů, navíc by ani nešla provést pro externí knihovny, které jsou dostupné pouze
			jako binární distribuce.
			S ohledem na tyto požadavky jsem navrhl a otestoval následující způsoby sledování alokací.
			\begin{description}
				\item[Zastavení procesu při alokaci] Pokud se na všechna volání alokačních funkcí umístí breakpoint, tak proces se zastaví při jakékoliv práci s
				dynamickou pamětí. Poté si z něj lze přečíst údaje o alokaci, zaznamenat si je a obnovit běh procesu. Toto řešení se ukázalo jako funkční,
				ale zastavování procesu při každé alokaci laděný proces zpomalovalo. Dále vytváření skrytých breakpointů a jejich odlišení od breakpointů vytvořených
				uživatelem zkomplikovalo implementaci komunikační knihovny. Navíc by se tento způsob zachytávání musel
				implementovat pro každý debugger zvlášť. Kvůli těmto důvodům jsem se rozhodl toto řešení nepoužít.
				
				\item[Obalení alokačních funkcí vlastními funkcemi] Alokační funkce v jazyce C jsou definovány v systémové knihovně, která poskytuje
				implementaci standardních funkcí a systémových volání. Často používanou implementací této knihovny na Linuxových systémech je glibc
				\footnote{https://www.gnu.org/software/libc/}. Při spuštění procesu na Linuxu se vyhledají dynamické knihovny, které daný proces vyžaduje,
				a poté se namapují do jeho adresního prostoru. Použitím proměnné prostředí \textbf{LD\_PRELOAD} lze určit
				seznam sdílených knihoven, které budou přednostně nahrány ke spouštěnému procesu\footnote{http://linux.die.net/man/8/ld.so}.
				Jelikož se tyto knihovny nahrávají jako první, symboly obsažené v nich mají přednost před později nahranými symboly. Pokud se tedy pro proces
				nahrají dvě sdílené knihovny, které obě obsahují vlastní implementaci funkce se stejnou hlavičkou, tak při zavolání této funkce se použije
				implementace z knihovny, která byla nahrána dříve.
				
				\parspace Této skutečnosti jsem využil pro vytvoření sdílené knihovny, která obsahuje deklarace dříve zmíněných alokačních funkcí.
				Při spuštění procesu je nahrána před systémovou knihovnou jazyka C a všechny dynamické alokace z laděného procesu poté volají funkce z mé knihovny.
				V ní dochází k otevření pojmenované roury, která slouží ke komunikaci s komunikačním rozhraním. % TODO: lepší název
				Při alokaci či dealokaci se nejprve odešlou informace o jejím typu a případné další parametry, jako je velikost alokovaných dat
				nebo adresa dealokované paměti. Poté je zavolána původní funkce ze systémové knihovny, která provede samotnou (de)alokaci.
				Adresa původní funkce musí být zjištěna za běhu programu pomocí
				funkce \textbf{dlsym}\footnote{http://linux.die.net/man/3/dlsym}. Prosté použití jejího názvu by totiž vyústilo v nekonečné rekurzivní volání, jelikož
				by se opět zavolala funkce z přednačtené knihovny. Funkce \textbf{dlsym} nicméně sama může alokovat malé množství dynamické paměti,
				její naivní použití by tedy vyústilo v nekonečnou rekurzi a přetečení zásobníku.
				Aby k tomuto nedošlo, tak se ve sdílené knihovně vytváří statické pole s 1024 vynulovanými
				byty, které je použito pro přidělení paměti vyžádané před nebo během načítání adresy alokačních funkcí. Pokud později dojde k dealokaci této
				paměti pomocí funkce \textbf{free}, tak je tato dealokace ignorována a není předána dále do systémové knihovny, protože ta nemá o této statické paměti
				žádné informace.
				
				\parspace Nevýhodou tohoto řešení je, že nebude fungovat, pokud bude laděný program používat staticky přilinkovanou systémovou knihovnu
				\footnote{Linker \textit{ld} linkuje knihovny staticky při použití přepínače \textbf{-static}}.
				Tato situace ale není obvyklá a v případě potřeby může tvůrce laděného programu pro účely ladění systémovou knihovnu linkovat dynamicky.
				Otevření souboru pro komunikaci a získávání adresy původních funkcí dále musí být synchronizováno, aby nedošlo k souběhu u vícevláknových aplikací.
				Toto řešení však nevyžaduje zastavení procesu při každé alokaci a poskytuje zachytávání alokačních funkcí nezávislé na použitém debuggeru, proto
				jsem se jej rozhodl v \textit{Devi} použít.
				
				\remark{Pro alokaci a namapování paměti lze využít i další funkce, např. \textbf{mmap} nebo \textbf{memalign}.
				Jejich explicitní použití v programech ale není běžné, takže je \textit{Devi} nesleduje.}
			\end{description}
			
			\InsertFigure{Figures/bak_io_alloc}{\textwidth}{Komunikace s laděným procesem}{fig:DebugeeIO}		
		\end{description}
			
	\subsection{Vizualizační aplikace}
	Pro samotné ladění aplikací a využití komunikační knihovny jsem vytvořil GUI aplikaci \textit{Devi}.
	Ta poskytuje grafické rozhraní pro veškeré naimplementované funkce knihovny a dále k nim přidává vizualizaci paměti procesu.
	
	\subsubsection{Vykreslovací komponenta}
	% TODO: canvas, drawable, UML, Clang
	
	\subsubsection{Používání aplikace}
	Na obrázku \ref{fig:DeviGui} je zobrazeno rozhraní aplikce a jsou na něm označeny její jednotlivé části. Následuje popis funkcí a možností použití
	jednotlivých částí rozhraní.
	
	\remark{Většina oken a panelů v \textit{Devi} popisuje nebo modifikuje stav laděného procesu a z toho důvodu s nimi lze pracovat pouze když je proces
	zastavený. Dnešní počítače zvládnou provádět miliardy operací za vteřinu a takto častá aktualizace informací o stavu procesu by byla nepraktická.}
	
	\begin{description}
		\item[Hlavní menu] V menu lze načíst spustitelný soubor aplikace, což je nutný první krok, pokud tuto aplikaci chceme v \textit{Devi} ladit.
			Spustitelný soubor musí být přeložený s ladícími symboly, jinak ladění nebude spolehlivě fungovat.
		\item[Panel ovládání procesu] Tento panel obsahuje nejpoužívanější příkazy sloužící k ovládání běhu procesu, jako je jeho zapnutí, přerušení, násilné
			ukončení a několik typů krokování. Jednotlivé příkazy jsou automaticky blokovány a povolovány podle stavu laděného procesu, nelze tedy např. zapnout
			proces, když už běží, anebo ho krokovat, když není zastavený.
		\item[Zdrojový kód] \textit{Devi} obsahuje okno, které zobrazuje obsah zdrojového kódu souboru v textovém editoru. Zobrazeno může být několik souborů naráz,
			lze mezi nimi přepínat pomocí záložek. Při načtení spustitelného souboru se automaticky načte a zobrazí soubor, který obsahuje vstupní bod daného programu
			% TODO: Je to vážně soubor s mainem?
			(funkci \textit{main}). Pokud se laděný proces zastaví na breakpointu v nějakém zdrojovém souboru, tak je tento soubor automaticky otevřen a zobrazen
			v editoru a ten se posune tak, aby byl daný breakpoint vidět a uživatel ho nemusel hledat. Pokud chce uživatel manuálně přidat breakpoint v jiném, než
			hlavním zdrojovém souboru, může využít funkce načtení libovolného zdrojového souboru z hlavního menu. Samotný textový editor nepovoluje změny zdrojového
			kódu, jelikož k tomu debugger není určen a neobsahuje ani žádnou vestavěnou podporu překladu kódu do spustitelné podoby. Kód je tak zobrazen pouze pro
			čtení, aby náhodou nedošlo k jeho nechtěné změně. Ve sloupci vedle zdrojového kódu lze přidávat a odebírat breakpointy. Zároveň se v něm při běhu procesu
			ukazuje, na kterém řádku v daném souboru je proces zastavený. Pokud je laděný proces zastavený, tak při přesunutí kurzoru myši nad proměnnou ve zdrojovém
			kódu se zobrazí její současná hodnota v procesu. Tuto funkcionalitu zajišťuje knihovna Clang\footnote{http://clang.llvm.org}, což je parser a překladač
			jazyků C, C++ a Objective C, který kód dále překládá do formátu překladače LLVM, a ten z něj poté generuje strojový kód.
		\item[Konzole] Pomocí konzole lze komunikovat s laděným procesem. Zobrazuje se v ní obsah jeho standardního (\textit{stdout}) i chybového (\textit{stderr})
			výstupu. Lze do ní také psát text, který se po odřádkování odešle laděnému procesu. Výstup, chybový výstup i vstup lze jednotlivě skrýt pomocí
			zaškrtávacích tlačítek.
		\item[Zásobník funkcí] V tomto okně je zobrazen stav zásobníku volaných funkcí pro aktivní vlákno. Lze se mezi nimi přepínat, což způsobí aktualizaci
			ukazatele současného řádku v editoru zdrojového kódu. Mezi zásobníkovými rámci lze přepínat i pomocí vizualizačního plátna, které je popsáno dále.
		\item[Seznam vláken] Zde je zobrazen seznam všech vláken laděného procesu spolu s jejich základními informacemi, jako je název nebo id. Pokud je proces
			zastavený, lze se mezi přepínat. Jelikož změna vlákna způsobí i změně zásobníku funkcí, tak při ní dochází ke kompletnímu překreslení vizualizačního
			plátna.
		\item[Seznam registrů] % TODO: měnit registry?
			Pokud je proces zastavený, tak je zde zobrazen seznam názvů a hodnot všech registrů procesoru. To může sloužit k nízkoúrovňovému ladění procesu, např.
			při práci s jazykem symbolických adres.
		\item[Zobrazení paměti] V tomto okně lze zadat hexadecimální adresu paměti, ze které se načte 40 bytů, které jsou poté zobrazeny ve formě dvou tabulek.
			% TODO: určit, kolik bytů zobrazit
			V první tabulce je přímá hodnota bytů ve formě čísla o rozsahu 0 až 255, ve druhé tabulce je pak jejich ASCII reprezentace, vhodná pro zkoumání textových
			polí v paměti. Kromě adresy v paměti lze zadat také název proměnné ze současně aktivního zásobníkového rámce. Adresa této proměnné se poté odvodí
			a zobrazí se hodnota její paměti.
		\item[Detail haldy] % TODO: zobrazit počet alokovaných bloků
			Toto okno zobrazuje graf velikosti paměti alokované na haldě v závislosti na čase. Pokud laděný proces běží, tak se hodnota grafu aktualizuje co vteřinu
			a zobrazuje tak stav haldy v reálném čase.
		\item[Vizualizační plátno] Na tomto plátně se při zastavení procesu vykreslí všechny jeho zásobníkového rámce (pro aktivní vlákno). V každém rámci je
			vykreslen seznam lokálních proměnných a parametrů dané funkce. U každé proměnné je zobrazen její název a současná hodnota, při podržení myši nad ní se dále
			zobrazí dodatečné informace, jako je její adresa v paměti. Na jednoduché typy proměnných, jako jsou primitivní datové typy (\textit{int}, \textit{bool}
			aj.), lze po kliknutí změnit jejich hodnotu pomocí textového pole. Aktivní zásobníkový rámec lze změnit kliknutím na hlavičku některého z vykreslených
			rámců, současný aktivní rámec je zvýrazněn červenou barvou.
		
	\end{description}

\end{section}
\begin{section}{Závěr}
\label{sec:Conclusion}
Po otestování \textit{Devi} na reálných zdrojových kódech a programech jsem došel k závěru, že vizualizace paměti procesu může poskytnout obstojnou
alternativu k prosté textové reprezentaci. Lze si díky ní lépe představit rozmístění paměti v adresním prostoru procesu a rychleji pochopit vztahy mezi objekty.
Nicméně objem paměti používané programy je v dnešní době obrovský a zobrazit jej naráz není možné. Grafická forma paměti také zabírá mnohem více místa než textový
popis a z toho důvodu nemusí stačit k zobrazení všech proměnných a částí paměti, které programátora ladícího daný proces zajímají. Pro největší flexibilitu
při ladění je tedy vhodné zkombinovat oba dva způsoby reprezentace paměti procesu.

\parspace Tato forma vizualizace paměti by dle mého názoru dala využít pro výuku programování. Jazyky C a C++ pracují bezprostředně s pamětí procesu,
bez několika vrstev abstrakcí, jako tomu bývá např. u skriptovacích jazyků nebo vyšších jazyků, jako je Java či C\#.
Pro pochopení sémantiky jejich jazykových konstrukcí, uspořádání struktur a polí v paměti apod. je nutné mít dobrou představu o paměťovém modelu,
který používají. A to nejen pro správné pochopení fungování programu, který je jejich kódem vygenerován, ale také z důvodu absence automatické správy paměti.
Programátoři, které v těchto jazycích začínají programovat, ovšem často nemají žádnou představu, jak je paměť v procesu uspořádána.
Kvůli toho často chování jejich programů považují za neintuitivní, protože si neuvědomují souvislosti existující za běhu procesu, které ze
samotného zdrojového kódu nejdou vyčíst. Zobrazení stavu paměti v intuitivní podobě, která zachycuje umístění proměnných, vznik zásobníkových rámců při volání
funkcí, dealokaci proměnných na konci bloku apod. může ve spolupráci s krokováním procesu usnadnit pochopení toho, jak programy vlastně fungují "na pozadí".

\parspace \textit{Devi} by mohl být v budoucnu rozšířen o další užitečné funkce. Pokud by se do něj přidala jednoduchá správa souborů a možnost kompilace
zdrojového kódu, mohl by sloužit jako jednoduché vývojové prostředí pro výuku programování v jazycích C a C++.
Díky tomu, že obsahuje komunikační knihovnu s abstraktním API pro debuggery je jednoduché přidat k němu podporu pro další debuggery. Určitě by bylo
zajímavé rozšířit tuto vrstvu o komunikaci s jinými debuggery, než je GDB, a srovnat jejich funkcionalitu a stabilitu.
Vizualizaci objektů by šlo také dále prohlubovat, např. vytvářením odlišných pohledů nad stejnými daty, přidáním diagramů zobrazujících rozsáhlá data nebo
přidáním podpory pro všechny paměťové kontejny standardní knihovny jazyka C++. Pro alternativu k grafické reprezentaci by také šlo přidat klasické textové
zobrazení proměnných ve stromové struktuře.
\end{section}

\bigskip
\begin{flushright}
Jakub Beránek
\end{flushright}

%\printbibheading[title=Zdroje, heading=bibintoc]
\printbibliography % TODO: do obsahu

\appendix
\begin{section}{Grafická rozhraní debuggerů}
\label{appendix:gui}
\InsertFigure{Figures/appendix_gui_gdb_tui}{\textwidth}{Textové rozhraní GDB (TUI)}{fig:AppendixGuiGdbTui}
\InsertFigure{Figures/appendix_gui_ddd}{\textwidth}{Rozhraní programu DDD}{fig:AppendixGuiDDD}
\InsertFigure{Figures/appendix_gui_clion}{\textwidth}{Rozhraní programu CLion (zdroj: https://www.jetbrains.com/clion)}{fig:AppendixGuiClion}
%\InsertFigure{Figures/appendix_gui_gede}{\textwidth}{Rozhraní programu Gede (http://gede.acidron.com/)}{fig:AppendixGuiGede}
\end{section}

\clearpage

\end{document}
