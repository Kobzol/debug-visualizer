\documentclass[bc,male,python,dept460]{diploma}						% jednostranny dokument

\usepackage[english, czech]{babel}
\usepackage[T1]{fontenc}
\usepackage[
	backend=biber,
	autolang=other,
	style=iso-numeric,
	sorting=none,
	sortlocale=cs_CZ,
  bibencoding=UTF8]{biblatex}
\usepackage[bottom]{footmisc}
\usepackage{xifthen}
\usepackage{float}
\usepackage{tikz-uml}
\usepackage{dirtree}

\tikzumlset{fill class=white!20, fill template=white!20}

\renewcommand\multinamedelim{\addcomma\space}	%  redefinice oddělování jmén autorů dle ISO690:2011
\renewcommand\finalnamedelim{\addspace\mainsstring{and}\space}

\newcommand{\parspace}[1][]{
	\ifthenelse{\isempty{#1}}{\vspace{5mm}}{\vspace{#1}}
	\par
}

\addbibresource{references.bib}

% remark - poznámka
% definition - definice
% theorem - věta
% example - příklad
% \begin{lstlisting}[label=src:Java,caption=Program v jazyce Java]
% \lstinputlisting[label=src:JavaExternal,caption={Program v jazyce Java, načtený z externího souboru}]{MyClass.java}
% \InsertFigure{Figures/Obr1}{40mm}{Pokusný obrázek -- absolutní velikost}{fig:SampleFigAbs}
% \InsertFigure{Figures/Obr1}{0.7\textwidth}{Pokusný obrázek -- relativní velikost}{fig:SampleFigRel}
% \InsertSidewaysFigure{Figures/Obr1}{0.6\textheight}{Pokusný obrázek -- otočený naležato}{fig:SampleFigSideway}

\ThesisAuthor{Jakub Beránek}
\ThesisTitle{Vizualizace ladění aplikací}
\EnglishThesisTitle{Visualization of application debugging}

\SubmissionDate{29. dubna 2016}

\Thanks{Chtěl bych poděkovat svému vedoucímu, Ing. Marku Běhálkovi, Ph.D., za pomoc a připomínky k tvorbě této práce.}

\CzechAbstract{Tato bakalářská práce se zabývá vizualizací ladění programů napsaných v jazyce C a C++. První část pojednává o
obecných principech ladění programů. %Jsou zde popsány konstrukce, které se při ladění používají, způsob, jakým ladící nástroje
%provádějí ladění programů a také existující ladících nástrojy a jejich grafické nástavby.
Druhá část popisuje běžně používané ladící nástroje a jejich grafické nádstavby.
Třetí část se zabývá implementací grafického nástroje, který vizualizuje pamět a stav procesu během jeho ladění za využití existujících ladících nástrojů  }

\CzechKeywords{ladění programů, vizualizace paměti}

%TODO: přeložit
\EnglishAbstract{This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract.}

\EnglishKeywords{typography, \LaTeX, master thesis}

\iffalse
\AddAcronym{API}{Application Programmable Interface}
\AddAcronym{GCC}{GNU Compiler Collection}
\AddAcronym{GDB}{The GNU Project Debugger}
\AddAcronym{GNU}{GNU's Not Unix!}
\AddAcronym{GUI}{Graphical user interface}
\AddAcronym{IPC}{Inter-process communication}
\AddAcronym{JSON}{JavaScript Object Notation}
\fi

% Zadame cestu a jmeno souboru ci nekolika souboru s digitalizovanou podobou zadani prace
% Pri sazbe se pak hledaji soubory Figures/Zadani1.jpg, Figures/Zadani2.jpg atd.
% Do diplomove prace se postupne vlozi vsechny existujici soubory Figures/ZadaniXXX.jpg
% Pokud toto makro zapoznamkujeme sazi se stranka s upozornenim
\ThesisAssignmentImagePath{Figures/Zadani}

% Zadame soubor s digitalizovanou podobou prohlaseni
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni
%\DeclarationImageFile{Figures/Prohlaseni.jpg}
% TODO: vytisknout, podepsat a naskenovat s reálným datem odevzdání

% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
%\listoftables
%\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
%\listoffigures
%\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
%\lstlistoflistings
%\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Zacneme uvodem
\begin{section}{Úvod}
	Jazyky C a C++ jsou velmi komplexní a pracují s hardwarem počítače na nízké úrovni.
	Kvůli absenci automatické správy paměti a možnosti provádět nebezpečné operace s paměťovými ukazateli jsou velmi náchylné ke vzniku těžko odhalitelných chyb.
	Mnoho chyb, hlavně u programátorů začínajících s těmito jazyky, vzniká proto, že programátor nemá jasnou představu o tom, co se děje na pozadí programu za
	jeho běhu. Zdrojový kód poskytuje pouze silně statický popis programu a nedokáže plně zachytit vznik, zánik a změny paměťových struktur běžícího programu.
	Vznik a zánik zásobníkových rámců při volání funkcí, dealokace proměnných na konci bloku, ve kterém byly deklarovány, rozdíl mezi alokací na zásobníku a na haldě,
	to vše jsou věci, které jsou potřebné pro pochopení fungování programů napsaných v jazycích C a C++. Přitom tyto informace nejsou ve většině výukových kurzů
	a učebnic programování explicitně vysvětlené, anebo jsou odloženy až do pokročilých lekcí. Programátorovi, který tomuto chování plně nerozumí,
	pak průběh programu může přijít neintuitivní.
	
	\parspace Pro hledání chyb v programu a lepší porozumění jeho chování lze použít \textbf{debugger} (ladící nástroj).
	Debuggery vytváří asociaci mezi zdrojovým kódem a spustitelným souborem a poskytují tak tvůrci kódu možnost ladit kód
	na vysoké úrovni abstrakce, tj. na úrovni samotného zdrojového kódu. Umožňují spustit program, na předem zvolených místech ho zastavit a poté jej spouštět
	po malých úsecích kód (tzv. ho "krokovat"), což se používá pro odhalení úseků programu, které obsahují chyby. Existující debuggery mají velké množství
	ladících funkcí, ale samy o sobě poskytují svému uživateli pouze ladění pomocí terminálu, což je u větších programů
	nepřehledné a pomalé řešení. Proto pro ně vzniklo velké množství grafických rozhraní, ať už samostatných nebo integrovaných v komplexních vývojových prostředích,
	které práci s nimi zpříjemňují. Tato rozhraní typicky zobrazují stav paměti procesu v textové podobě, která je sice vhodná pro rychlé
	zjištění hodnot proměnných, ale nezobrazuje vztahy mezi jednotlivými objekty ani jejich umístění v paměti.
	Nedovoluje si tak udělat ucelenější, globální pohled na paměť procesu a pochopit, co přesně se v ní stane po provedení určitého příkazu.
	Tento širší pohled by mohla poskytnout grafická reprezentace paměti, která umožňuje popsat umístění objektů v jednotlivých segmentech paměti,
	zobrazit vztahy mezi objekty (např. paměťové ukazatele) a poskytnout snadno pochopitelný pohled na stav paměti.
	
	\parspace Grafická vizualizace paměti programů není novým tématem, zabývalo se jim už mnoho programů. Za zmínku stojí \textbf{Python Tutor}, který vizualizuje
	paměť programu ve formě objektů a ukazatelů, které objekty propojují\cite{GuoSIGCSE2013}.
	Primárně je určen pro jazyk Python, ale obsahuje rozšíření i pro jazyky Java, JavaScript, TypeScript, Ruby, C a C++.
	Tento nástroj ovšem nezobrazuje stav programů během jejich běhu, ale pouze zpětně přehrává jejich stav, který je během jejich běhu ukládán.
	Dovoluje tedy ladit program až po jeho skončení (tzv. post-mortem debugging). Tento způsob je v určitých případech (např. u masivně
	paralelních aplikací) jediným, který se dá použít, ale u většiny programů, kde je to možné, je užitečnější je ladit přímo za jejich běhu a mít
	tak možnost ovlivňovat jejich průběh. Tento nástroj navíc za běhu programu ukládá po každém příkazu (resp. instrukci) celkový stav paměti,
	což zabírá velké množství paměti. Nemůže tak být použit pro ladění větších a složitějších programů. Sorva ve své práci uvádí a
	kategorizuje několik desítek programů, které se zabývají zobrazováním stavu běžícího procesu v rozlišných formách\cite[140]{sorva2012visual}.
	Hodně z nich slouží přímo jako nástroje pro výuku programování. 
	
	\parspace Tato práce si klade za cíl vytvořit jednoduše použitelné grafické rozhraní, které bude umožňovat ladit programy a vizualizovat paměť procesu
	ve formě diagramu. Mělo by být použitelné jak pro výuku programování a pochopení fungování programů napsaných v jazycích C a C++, tak pro ladění reálných
	aplikací. Diagram paměti by měl zobrazovat jednotlivé objekty a struktury, jejich hodnotu, umístění a vztahy s ostatními objekty.
	Tímto by měl poskytnout svým uživatelům snadněji si představit, co se v děje v paměti programu za jeho běhu.
	Kromě ladění může být tento diagram použit i pro vizualizaci průběhu určitých typů algoritmů (např. třídících). Mimo vizualizaci paměti by měl program
	umožňovat používat nejběžnější funkce debugggerů, jako je krokování, inspekce a úprava paměti nebo přepípání mezi zásobníkovými rámci a vlákny.
	Tento program by neměl být závislý na jednom konkrétním debuggeru, aby k němu šla lehce doimplementovat podpora různých debuggerů.
	
	\parspace Teoretický popis ladění v této práci i samotný vizualizační program je zaměřený na programy pro operační systémy založené na Linuxovém jádře.
	Pojmem Linuxový systém se v této práci myslí libovolná distribuce Linuxu. Pro označení programů, které umožňují ladění jiných programů,
	je zde používán termín debugger, jelikož se jedná o často používaný programátorský termín a v češtině pro něj neexistuje zavedená alternativa.

	\parspace Kapitola \ref{sec:DebuggingPrinciples} popisuje obecné principy ladění, které jsou společné pro používání libovolného debuggeru.
	Vysvětluje také terminologii potřebnou pro pochopení dalšího textu. Po ní následuje kapitola \ref{sec:ExistingDebuggers}, pojednávající o existujících
	debuggerech a jejich grafických rozhraních. Kapitola \ref{sec:DeviImplementation} se poté věnuje návrhu a vývoji vizualizační aplikace a
	komunikačního rozhraní pro přístup k debuggerům.
\end{section}
\begin{section}{Principy ladění programů}
\label{sec:DebuggingPrinciples}
	Tato kapitola popisuje obecné principy fungování ladících nástrojů, způsob mapování binárních instrukcí programu zpět do jeho zdrojového kódu,
	krokování běžícího procesu a běžné konstrukce používané při ladění. Konkrétně je popis zaměřen na programy napsané v jazycích C a C++
	v prostředí Linuxových systémů používající procesory z rodiny Intel x86. %TODO: důvod?%
	Popsané principy jsou ale obecné a lze je aplikovat na libovolný operační systém.
		
	\subsection{Signály}
		Pro ladění programu je nutné mít možnost číst jeho paměť, aby šly zkoumat hodnoty proměnných za jeho běhu, a také ho zastavit, jelikož
		programy za běhu provádějí obrovské množství instrukcí za vteřinu a zkoumat takto rychle se měnící datový tok by bylo obtížné.
		Aby šlo proces zastavit, musí mu jiný proces anebo sám operační systém zaslat signál.
		Signály jsou zprávy, které lze zaslat běžícímu procesu, ten si je může odchytit a zareagovat na ně.\cite[21]{tanenbaum}
		Slouží pro meziprocesní komunikaci a fungují jako softwarová obdoba hardwarových přerušení procesoru.
		Jakmile proces obdrží signál, který očekává, tak si uloží hodnoty svých registrů a přejde do procedury, která tento signál obslouží.
		Pokud proces obdrží signál, pro který si nepřipravil žádnou reakci, tak se provede implicitně nadefinovaná akce pro daný typ signálu.
		V Linuxových systémech je definováno několik desítek standardních signálů, v závislosti na verzi a typu operačního systému.
		Na signály SIGKILL, sloužící k okamžitému ukončení procesu a SIGSTOP, sloužící k zastavení procesu, nemá proces možnost zareagovat ani
		zjistit, že mu byly poslány.
	
	\subsection{Krokování}
		Operační systémy obvykle poskytují nástroj, pomocí kterého lze buď spustit proces, anebo se připojit k již běžícímu procesu, a následně ho ovládat
		a přistupovat k jeho paměti. Linuxové systémy pro tento účel poskytují systémové volání \textbf{ptrace}\footnote{http://linux.die.net/man/2/ptrace},
		které umožňuje zachytávat signály zaslané sledovanému procesu. Proces sledovaný pomocí funkce ptrace je zastaven při přijetí jakéhokoliv signálu
		(kromě signálu SIGKILL, který se pokusí proces okamžitě ukončit). Tohoto mechanismu využívají ladící nástroje, které proces sledovaný pomocí
		ptrace můžou po jeho zastavení znovu spustit, přistupovat k jeho paměti a ovlivňovat jeho průběh. Pokud je sledovaný proces potomkem procesu,
		který ho sleduje, bude při jeho spuštění vyvolán signál SIGTRAP, který dovolí rodičovi odchytit začátek provádění potomka. Jakmile je proces
		zastavený, může ho ladící nástroj tzv. krokovat, tedy spouštět instrukci po instrukci. K tomu lze použít funkci ptrace s příznakem PTRACE\_SINGLESTEP,
		která provede přesně jednu instrukci v laděném procesu (proces se také zastaví, pokud se dostane na vstupní nebo výstupní bod systémového volání).
		Ladící nástroje obvykle nabízí krokování na vyšší úrovni než pouze po jedné instrukci, jelikož to by bylo zbytečně zdlouhavé (u vyšších programovacích
		jazyků se jeden řádek zdrojového kódu může mapovat na desítky až stovky instrukcí). Obvykle jsou dostupné následující krokovací akce:
		\begin{description}
			\item[Krok po řádku] - program se obnoví, provede instrukce odpovídající jednomu řádku zdrojového kódu a poté se opět zastaví
			\item[Krok dovnitř funkce] - funguje stejně jako krok po řádku, ale program se zastaví i při zavolání funkce
			\item[Krok ven z funkce] - program bude pokračovat, dokud neskončí funkce, ve které se právě nachází
		\end{description}
		
	\subsection{Obousměrné mapování zdrojového kódu na instrukce}
		Aby mohly ladící nástroje nabízet krokování na úrovni (řádků) zdrojového kódu, musí umět namapovat zdrojový kód na instrukce vygenerovaného
		spustitelného programu i instrukce zpět na zdrojový kód. Jelikož programy psané v jazycích C a C++ jsou kompilované a po jejich překladu nejsou
		ve výsledném binárním souboru téměř žádné informace o jejich zdrojovém kódu, musí být přeloženy ve speciálním režimu, který při překladu vygeneruje
		metadata s mapováním zdrojového kódu a vloží je do přeloženého programu. V překladačích jazyka C/C++ se tohoto dá standardně dosáhnout použitím
		řepínače \textbf{-g}. Existuje několik formátů ukládání těchto metadat, dnešním de facto standardem na Linuxových systémech je DWARF
		\footnote{http://dwarfstd.org}. Ten ukládá proměnné, datové typy, procedury a další údaje ze zdrojového kódu ve stromové struktuře.
		Pro ušetření místa obsahuje instrukce pro speciální konečný automat, který implementují ladící nástroje a pomocí něho poté získávají
		informace o původním zdrojovém kódu.
		
		\parspace Samotné mapování zdrojového kódu není pro ladící nástroj užitečné, pokud je výsledný program zoptimalizovaný překladačem. Po optimalizaci
		totiž program nemusí obsahovat všechny původní proměnné, funkce a jeho průběh ani nemusí přesně odpovídat jeho zdrojovému kódu. Při použité málo agresivní
		optimalizace někdy lze programy úspěšně ladit, ale pro zajištění co nejpřesnějšího ladění programů je obvykle nutné optimalizace úplně vypnout. Toho lze
		v překladačích obvykle dosáhnout použitím přepínače \textbf{-O0}.
	
	\subsection{Zásobník}
		Adresní prostor procesů je rozdělen do několika segmentů\cite[53]{tanenbaum}. Jedním z nich je zásobník (\textit{stack}), což je úsek paměti, který
		obsahuje lokální proměnné a parametry funkcí a údaje o jejich jednotlivých invokacích. Pokaždé, když proces zavolá funkci, tak se na zásobník uloží tzv.
		\textit{zásobníkový rámec}. Informace o současném rámci jsou uloženy v procesorových registrech \textit{esp} a \textit{ebp} na 32-bitových systémech
		a \textit{rsp} a \textit{rbp} na 64-bitových systémech. Registr \textit{ebp} ukazuje na bázi současného rámce a registr \textit{esp} jeho vrchol, který
		má ale ve skutečnosti nižší adresu v paměti, jelikož zásobník obvykle roste v paměti směrem dolů. Při zavolání funkce se na zásobník vloží předané parametry,
		návratová adresa, na kterou se má skočit po dokončení funkce, hodnota báze předchozího rámce a lokální proměnné dané funkce.
		Jelikož registr \textit{ebp} ukazuje obvykle doprostřed zásobníkového rámce, tak se kód funkce na lokální proměnné a parametry odkazuje
		relativně k jeho hodnotě. Detaily ukládání parametrů a získávání návratové hodnoty ze zásobníkového rámce jsou silně závislé na konkrétní architektuře
		a použitého způsobu volání funkcí (tzv. \textit{call convention}).
		
		\remark{Na architektuře x86-64 je definovaná červená zóna\cite[16]{x64abi}, což je oblast o velikosti 128 bytů, která je umístěná pod ukazatelem vrcholu
		zásobníku (registr \textit{rsp}). Lze jí použít k libovolným účelům, překladače tento prostor obvykle využívají u listových funkcí (tj. funkcí,
		které nevolají žádné další funkce). U nich se totiž nemusí nijak měnit hodnota \textit{rsp}, a proto zde můžou libovolně používat paměť bez
		zbytečné změny hodnoty tohoto registru. Je zaručeno, že tato paměť nebude modifikována žádnými obslužnými procedurami signálů ani přerušení.}
		
		\parspace Z hlediska ladění je zásobník zajímavý, jelikož jeho stav reprezentuje funkci, ve které je proces zastaven, a zároveň také všechna volání
		funkcí, které dané situaci předcházely. Lze tak analyzovat, jakou cestou se proces dostal do určitého stavu, což je často jedna z prvních věcí, která
		programátora při ladění zajímá. Pokud překladač vygeneroval kód který korektně při volání každé funkce ukládá hodnotu \textit{ebp} a provádí
		celý prolog i epilog funkce, je pro debugger jednoduché provést zpětný průchod zásobníkem a zjistit informace o všech zásobníkových rámcích.
		Mimo debuggery se tyto údaje mohou používat i pro implementaci výjimek v jazyce C++.
		Toto chování nicméně spotřebuje jeden registr procesoru pouze pro ukládání informací o rámcích a vyžaduje provedení celého zmíněného postupu při každém
		zavolání funkce, čímž může proces zpomalovat.
		
		\parspace Při návrhu architektury x86-64 bylo rozhodnuto, že toto chování nebude vynucováno\cite[16]{x64abi}, a překladače této skutečnosti
		obvykle využívají, rámce explicitně nezaznamenávají a adresy lokálních proměnných a parametrů počítají relativně od vrcholu zásobníku,
		který je uložen v registru \textit{rsp}. Poté je ale někdy nemožné zobrazit zásobník volaných funkcí v debuggeru, a proto je vhodné se ujistit,
		že se rámce zaznamenávají\footnote{U překladače GCC to lze zajistit pomocí přepínače \textit{-fno-omit-frame-pointer}.
		Tato volba je implicitně zapnutá při úrovni optimalizace -\textit{O0}. }.
		Debuggery můžou informace o volaných funkcí získat i z ladících metadat, pokud je s nimi daný program přeložen,
		nebo analýzou strojového kódu procesu, ale tato řešení nemusí být vždy spolehlivá.
	
	\subsection{Běžné konstrukce ladících nástrojů}
		\begin{description}
			\item[Breakpoint]
				Většina ladících nástrojů poskytuje svým uživatelům možnost zastavit běh laděného procesu pomocí tzv. breakpointu.
				Jedná se o označení řádku v zdrojovém kódu programu, na kterém se program za běhu zastaví a umožní tak uživateli prozkoumat paměť procesu a krokovat ho.
				Nejčastěji je implementován tak, že ladící nástroj nejdříve zjistí z daného řádku adresu instrukce ve vygenerovaném spustitelném souboru, kterou tento
				řádek představuje, uloží si ji a nahradí ji instrukcí přerušení s kódem 3. Toto přerušení je určeno speciálně pro ladění procesů, jelikož generuje
				instrukci o velikosti jednoho bytu, a lze jím tak nahradit libovolnou instrukci\cite[306]{intel}. Pokud by měla více než jeden byte, mohlo by ses
				stát, že by tato instrukce přepsala více než jednu instrukci, což by mohlo způsobit nevalidní chování programu. Jakmile program během svého běhu
				provede tuto instrukci, vyvolá se signál SIGTRAP, který ladící nástroj odchytí a laděný proces se tímto zastaví. Pokud se uživatel rozhodne proces
				opět sputit, ladící nástroj zkopíruje původní instrukci programu (kterou si dříve uložil) na místo, kde vložil přerušení, nastaví na ni ukazatel
				příští instrukce a proces opět spustí.
				Některé procesory nabízí také hardwarový breakpoint, který sice může být rychlejší, ale obvykle kvůli tomu, že je implementován v hardwaru, tak poskytuje
				vytvoření pouze několika breakpointů zároveň.
			\item[Tracepoint]
				V některých případech není možné laděný proces pozastavit k prozkoumání jeho paměti, jelikož jeho průběh může záviset na reálně uběhlém čase a zastavení
				tedy může způsobit, že program neproběhne korektně. Pro tyto situace lze použít tracepoint, u kterého se uvede lokace v programu a paměť, která má být
				sledována. Pokaždé, když se laděný proces dostane na tuto lokaci, tak je uložena sledovaná paměť a po skončení běhu procesu si lze zpětně prohlédnout,
				jak se tato paměť v průběhu programu měnila.
			\item[Watchpoint]
				Pokud je potřeba zastavit program ne na konkrétním místě, ale při změně dané hodnoty v paměti, lze použít watchpoint. Ten se může hodit například pro
				kontrolu změn globálních proměnných. Pokud nenabízí procesor hardwarovou podporu pro watchpointy, ladící nástroj prochází laděný proces instrukci po
				instrukci, testuje hodnotu sledované paměti a pokud se tato hodnota změní, tak program zastaví. Tento proces může zpomalit laděný proces až o
				dva řády\footnote{https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html}.
			\item[Catchpoint]
				Tuto konstrukci lze použít pro zachycení událostí procesu, jako jsou načtení sdílené knihovny, vyvolání hardwarové či softwarové výjimky, provedení
				systémového volání anebo přijetí signálu. Většina těchto událostí je ze své podstaty asynchronní, nelze u nich tedy dopředu určit, kdy budou zavolány
				a použití breakpointu tedy není možné.
		\end{description}		
\end{section}
\begin{section}{Existující ladící nástroje}
\label{sec:ExistingDebuggers}
	Ladících nástrojů pro jazyky C a C++ existuje velké množství, v této kapitole jsou popsány dva z nejpoužívanějších nástrojů, GDB a LLDB, které byly dále
	použity při implementaci vizualizačního nástroje. Jsou zde taky popsány jejich vybrané grafické nádstavby.

	\subsection{GDB}
		GDB (The GNU Debugger) je standardním ladícím nástrojem pro Linuxové systémy, často je v těchto systémech už předinstalovaný.
		Jeho hlavním zaměřením je ladění programů napsaných v jazycích C a C++, ale podporuje mimo jiné i Adu, Objective-C, Pascal, Fortran, Javu
		a Go\cite{gdb-languages}. Podporuje velké množství rodin procesorů, například ARM, AVR, Itanium, MIPS, PowerPC, SPARC a samozřejmě x86 i x86-64.
		Lze jej spustit i na platformě Windows pomocí prostředí emulujících Linux, jako je Cygwin nebo MinGW. Byl vydán v roce 1986 a k roku
		2016 stále vycházejí nové verze.
		
		\par Umí spolupracovat s programy přeloženými libovolným překladačem jazyků C a C++, pokud je dodržen jejich standard. Navíc ještě obsahuje
		speciální podporu pro překladač GCC (GNU Compiler Collection), který pro něj umí vygenerovat dodatečná ladící metadata.
		GDB obsahuje základní funkce nezbytné pro každý ladící nástroj, jako je načtení ladících metadat v mnoha formátech (podporuje DWARF i několik dalších
		formátů), vytváření breakpointů, tracepointů a watchpointů, krokování programu a čtení i zápis paměti programu.
		Mimo to ale nabízí i pokročilé funkce, které ovšem nemusí být podporované všemi procesory a platformami, s kterými GDB jinak umí pracovat.
		
		\begin{description}
			\item[Vzdálené ladění]
				GDB dokáže být spuštěn na jednom zařízení a ladit program spuštěný na jiném zařízení pomocí síťové komunikace (obvykle pomocí protokolu TCP).
				Toto může být užitečné, pokud není dostupný fyzický přístup k systému, který je potřeba odladit.
				Vzdálené ladění se dá využít také k ladění jádra (kernelů) operačního systému, čehož je využito například v programu KGDB, který se používá k ladění
				jader operačních systémů Linux a FreeBSD pomocí sériového připojení.
			\item[Ladění vícevláknových aplikací]
				Pokud GDB ladí program, který využívá více než jedno vlákno, může pracovat v několika rozlišných módech\cite{gdb-multithreading}.
				V All-stop módu se při zastavení jednoho vlákna zastaví také všechna ostatní vlákna, aby šlo mezi vlákny přepínat a číst jejich paměť bez toho,
				aby se paměť mezitím nějak změnila. Pokud je nutné zastavit pouze jedno vlákno, tak, aby ostatní pokračovala v běhu, lze použít tzv. Non-stop mód,
				který vždy zastaví pouze vlákno, které narazí na breakpoint, a zbytek vláken nechá běžet. S tímto módem je vhodné použít asynchronní ovládání GDB,
				pomocí kterého lze zasílat ladící příkazy programu i za jeho běhu a ovládat tak pouze zastavené vlákno, i když zbytek vláken stále běží.
			\item[Provádění výrazů]
				Pomocí GDB lze nejenom číst a zapisovat paměť laděného procesu na úrovni bytů v adresním prostoru procesu, ale v podporovaných jazycích, hlavně
				v C a C++, lze také provádět libovolné jazykové výrazy, volat funkce programu a systémová volání a pracovat s hodnotami na úrovni proměnných
				laděného programu.
			\item[Spolupráce s Valgrindem]
				Valgrind je nástroj pro profilování a kontrolu paměťové korektnosti programů, který se využívá k hledání paměťových chyb, jako je například memory
				leak. Vytváří virtuální stroj, ve kterém spouští zkoumaný program a kvůli této vlastnosti jej nelze ladit klasickými přístupy. GDB poskytuje
				možnost připojit se k programu spuštěnému ve Valgrindu a vzdáleně ho takto ladit.
			\item[Analýza logu z ukončeného procesu]
				Procesy, které se ukončí s chybou, např. po vyvolání výjimky, můžou vygenerovat výpis paměti (core dump), který lze poté načíst v GDB a zanalyzovat ho.
				Lze tak například zobrazit stav zásobníku volání funkcí v momentu, kdy program zhavaroval, a zjistit tak, který kód programu způsobuje chybu.
			\item[Zpětné provádění instrukcí]
				Při ladění nastává často situace, kdy proces zajde moc daleko a přeskočí instrukci, kterou chce uživatel zkoumat. GDB umí spouštět určité instrukce
				zpětně, a může tedy krokovat program nejenom dopředu, ale i dozadu. Všechny změny a vedlejší efekty, které proběhly v paměti, jsou tak smazány a
				navráceny do původního stavu (pokud to daná platforma a stav programu dovoluje).
		\end{description}
		
		GDB nemá vlastní grafické rozhraní, je ovládán z příkazové řádky. Kromě toho ale podporuje také spouštění skriptů v Pythonu pomocí API,
		které bylo použito pro implementaci vizualizačního nástroje a je popsáno dále v textu.
	\subsection{LLDB}
		Ladící nástroj LLDB\footnote{http://lldb.llvm.org} je založen na sadě knihoven, které využívají infrastruktury LLVM a překladače Clang.
		LLVM je univerzální překladače, který dokáže překládat velké množství jazyků do své vnitřní, jazykově nezávislé reprezentace, kterou umí
		optimalizovat a vygenerovat z ní dále spustitelný soubor pro libovolnou kompatibilní platformu. Obsahuje také kompletní implementaci standardní
		knihovny jazyka C++, která plně podporuje jeho nejnovější standard, C++11. Clang je nádstavbou LLVM, která analyzuje a překládá programy v jazyce
		C a C++. Celá LLVM architektura je postavena na modulárních komponentech, které spolupracují a dají se lehce využít ve formě knihovny.
		Nabízí tak modernější alternativu k programům GCC a GDB. Ty jsou sice stabilnější a prověřenější, ale jelikož existují už desítky let a musí udržovat
		zpětnou kompatibilitu, tak je těžší je využít jako modul do jiného programu. Z tohoto důvodu rovněž pomaleji přecházejí k novým standardům.
		
		\parspace Umí ladit programy napsané v jazycích C, C++, Objective-C a Swift na platformách OS X, Linux, Free BSD a Window. Podporuje tedy méně jazyků
		i platforem, než GDB, ale narozdíl od něho je podporován, a stal se také standardním ladícím nástrojem, i operačními systémy OS X a iOS.
		Nabízí většinu standardních funkcí ladících nástrojů, jako je krokování kódu, vytváření breakpointů a čtení a zápis paměti procesu.
		Jelikož je stále ve vývoji, tak zatím neobsahuje některé pokročilejší funkce, které nabízí GDB, například zpětné provádění instrukcí.

	\subsection{Grafická rozhraní}
		Grafických rozhraní pro debuggery GDB a LLDB existuje několik desítek. Některé z nich jsou samostatné programy podporující pouze ladění, další jsou
		jednou z mnoha součástí integrovaných vývojových prostředí. Rozhraní těchto nástrojů se obvykle skládá z textového editoru, který obsahuje zdrojový kód,
		ovládacích prvků, které kontrolují průběh laděného procesu. Dále také často nabízí manipulaci a zobrazování registrů, lokálních proměnných a parametrů
		funkcí. Ukázky uživatelského rozhraní jednotlivých programů si lze prohlédnout v příloze \ref{appendix:gui}. Následuje popis jednoho zástupce
		ze skupiny samostatných (DDD), integrovaných (Clion) a textových (TUI) uživatelského rozhraní pro ladění programů.
	
		\begin{description}
			\item[TUI]
				Text User Interface je grafickým rozhraním vestavěným přímo v GDB, které zobrazuje stav průběhu v několik terminálových oknech pro větší přehlednost
				programu. Je postaveno na knihovně curses, která umožňuje vytvářet textové uživatelské rozhraní s pokročilými funkcemi přímo v terminálu. TUI lze
				spustit předáním parametru \textbf{-tui} při spouštění GDB anebo stisknutím kláves CTRL+X či spuštěním příkazu \emph{tui enable} za jeho běhu.
				LLDB obsahuje podobné rozhraní také, ale není zatím oficiální součástí nástroje, jedná se pouze o nezávazně vyvíjený doplněk.
			\item[DDD]
				DDD, neboli Data Display Debugger, je grafické prostředí podporující velké množství ladících nástrojů, mimo jiné GDB, pydb, DBX nebo Ladebug.
				Mimo klasického zobrazování zdrojového kódu programu nabízí i pokročilé vizualizační funkce. Umí kreslit grafy z hodnot paměti procesu
				anebo zobrazovat vztahy mezi objekty v paměti ve formě grafu. Jeho poslední verze vyšla v roce 2009, není už tedy v současnosti aktivně udržován.		
			\item[Clion]
				Clion je integrované vývojové prostředí založené na vývojové platformě IntelliJ. Nabízí mimo jiné statickou analýzu kódu psaného v jazycích
				C a C++, což pomáhá v odhalování velkého množství chyb již během psaní programu. Tato analýza zároveň usnadňuje ladění kódu poskytováním
				automatického doplňování výrazů a proměnných, které lze v laděném procesu sledovat. Během ladění Clion zobrazuje vedle názvů proměnných
				ve zdrojovém kódu jejich současnou hodnotu, což velmi urychluje pochopení stavu výpočtu.
		\end{description}

\end{section}
\begin{section}{Implementace vizualizačního nástroje}
\label{sec:DeviImplementation}
  Cílem této práce bylo navrhnout a naimplementovat program, který bude ladění programu vizualizovat ve formě grafu objektů v paměti, a otestovat,
	jestli tato grafická reprezentace usnadňuje ladění programů a pochopení průběhu jednoduchých algoritmů.
	Tato kapitola pojednává o návrhu a implementaci tohoto nástroje, spolu s implementací knihovny pro komunikaci s debuggery.
	Vizualizační nástroj jsem pojmenoval a dále jej v textu budu označovat jako \textit{Devi}.
	
	\subsection{Specifikace požadavků}
	Program by měl existovat jako klasická GUI aplikace s okny. Jeho hlavní funkcí by mělo být vizualizovat stav laděného procesu zobrazováním části jeho
	adresního prostoru. Zobrazovat by měl hlavně zásobník, který představuje současný stav a pozici procesu a z hlediska ladění se jedná o první místo,
	kde lze začít hledat chyby.
	Aby se dal program použít pro ladění reálně používaných aplikací, měl by poskytovat přístup ke všem běžným
	funkcím debuggerů. Měl by také být nezávislý na použitém debuggeru. Následuje seznam základních funkcí, které by měl program svým uživatelům nabízet.
	
	\begin{itemize}
		\item Asynchronní komunikace s debuggerem
		\item Načítání binárních i zdrojových souborů
		\item Zobrazování zdrojového i strojového kódu programu
		\item Vytváření a odebírání breakpointů
		\item Manipulace s procesem (spuštění, pozastavení, zastavení)
		\item Krokování (krok po řádku, krok dovnitř funkce, krok ven z funkce)
		\item Komunikace s procesem v reálném čase (přes standardní vstup a výstup)
		\item Přepínání zásobníkových rámců
		\item Přepínání vláken
		\item Zobrazování registrů a paměti na úrovni bytů
		\item Manipulace s hodnotami proměnných
		\item Vizualizace objektů v paměti ve formě grafu
	\end{itemize}
	
	\subsection{Architektura}
	\par Pro implementaci programu jsem zvolil programovací jazyk \textbf{Python}\footnote{http://www.python.org} ve verzi 2.7. Novější verze 3.x nebyla použita
	z důvodu zachování kompatibility s knihovnami, které jsou v programu použity a Python 3 nepodporují (mj. Python API pro LLDB a libclang).
	Python jsem vybral, protože je vhodný k rychlému vývoji aplikací, existuje pro něj několik rozhraní pracujících s debuggery a umí snadno používat
	kód napsaný v jazycích C a C++. Navíc je multiplatformní, což by usnadnilo případný port aplikace na jiný operační systém.
	
	\parspace Pro vývoj grafického rozhraní programu jsem vybral knihovnu \textbf{GTK+ 3}\footnote{http://www.gtk.org}. Jedná se o volně dostupný
	\footnote{Pod licencí LGPL 2.1}, multiplatformní grafický software umožňující tvorbu uživatelského rozhraní, který je používán mimo jiné i
	některými manažery plochy pro Linux (např. v GNOME\footnote{https://www.gnome.org/technologies}). Kromě možnosti tvorby vlastních
	GUI prvků obsahuje několik desítek běžně používaných prvků, které jsou předpřipravené k okamžitému použití a usnadňují tak rychlý vývoj aplikací.
	
	\parspace Nástroj je tvořen dvěmi samostatnými komponentami, aplikací s grafickým rozhraním, která slouží k vizualizaci a k interakci s laděným procesem,
	a knihovny, která poskytuje rozhraní pro komunikaci s libovolným debuggerem. Obrázek \ref{fig:DeviArchitecture} zachycuje pohled na architekturu aplikace
	z vysoké úrovně.
	Uživatelské rozhraní komunikuje s knihovnou, která zprostředkovává komunikaci s debuggerem. Na obrázku jsou zobrazeny tři implementace této komunikační vrstvy,
	které jsou popsány dále v textu. Debugger zajišťuje komunikaci a manipulaci s laděným procesem. Celá aplikace je tak rozdělena do několika
	vrstev, které jsou na sobě nezávislé.
	
	\InsertFigure{Figures/bak_architektura}{\textwidth}{Architektura programu \textit{Devi}}{fig:DeviArchitecture}
		
	\subsection{Knihovna pro komunikaci s debuggery}
	\label{sec:DebuggerApi}
		Tato knihovna tvoří rozhraní pro komunikaci s libovolným ladícím nástrojem. Definuje abstraktní typy popisující laděný proces a není tak závislá na
		použitém ladícím nástroji. Není nijak závislá ani na grafickém rozhraní nástroje, lze ji tedy použít pro programovatelné ovládání debuggerů i v jiném
		projektu. Knihovna obsahuje třídy představující části laděného procesu, které jsou dostatečně obecné na to, aby se daly aplikovat na libovolný
		proces i debugger. Následuje popis těchto typů.
		
		\begin{description}
			\item[Type] představuje datový typ proměnné, obsahuje jeho název, kategorii a velikost
			\item[Variable] představuje proměnnou, obsahuje její název, datový typ, adresu v paměti, hodnotu a potomky
			\item[Frame] představuje rámec zásobníku, obsahuje jeho úroveň v zásobníku a název a lokaci funkce, z které je vyvolán % TODO
			\item[InferiorThread] představuje vlákno procesu, obsahuje jeho identifikátor, název, stav a současný zásobníkový rámec
			\item[ThreadInfo] uchovává seznam všech vláken v procesu a také současně zvolené vlákno
			\item[Breakpoint] představuje breakpoint, obsahuje jeho identifikátor a zdrojový soubor a řádek, na kterém je umístěn
			\item[Register] představuje registr procesoru, obsahuje jeho název a hodnotu
			\item[HeaBlock] představuje blok paměti naalokované na haldě, obsahuje adresu a velikost v bytech
		\end{description}
		
		\parspace Dále jsou v knihovně třídy, které tvoří obecné API pro přístup k debuggeru. Slouží jako rodičovské třídy pro jednotlivé implementace
		komunikace s debuggerem. Jejich smyslem není implementovat společné chování, jelikož jednotlivé debuggery a implementace přístupu k nim
		se od sebe můžou značně lišit, a tak poskytují pouze rozhraní. Následuje seznam tříd tohoto rozhraní.
		
		\begin{description}
			\item[Debugger] představuje abstrakci ladícího nástroje, který umožňuje načtení binárního souboru programu, jeho spuštění, zastavení
			a krokování. Dále také uchovává stav laděného procesu a obsahuje všechny ostatní komponenty rozhraní vyjmenované níže.
			\item[VariableManager] se stará o čtení registrů a paměti procesu a o získávání a změnu jeho proměnných
			\item[ThreadManager] se stará o získávání a volbu vláken a zásobníkových rámců
			\item[FileManager] se stará o získávání současné pozice a hlavního souboru laděného procesu. Poskytuje také převod zdrojového kódu
			na strojový kód.
			\item[BreakpointManager] se stará o přidávání, mazání a načítání breakpointů
			\item[IOManager] se stará o komunikaci s laděným procesem pomocí čtení z jeho standardního a chybového výstupu a zápisu do jeho standardního vstupu
		\end{description}
		
		Pro účely této práce jsem v této knihovně vytvořil a otestoval několik implementací pro komunikaci s GDB a LLDB.

		\subsubsection{Python API pro GDB}
		GDB obsahuje rozhraní \footnote{https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html}, které nabízí možnost načtení skriptů v Pythonu 2, které
		můžou ovládat GDB a přistupovat k jeho vnitřním funkcím. Většina nejpoužívanějších funkcí GDB je tak dostupná ve formě tříd a funkcí.
		Funkce GDB, které v API nejsou obsaženy, lze vyvolat pomocí přímého provádění textových příkazů.
		Nevýhoda tohoto přístupu je, že toto API neumí samo spustit instanci GDB a musí tak být načteno v již běžícím GDB procesu.
		Nelze jej tedy použít přímo v kódu jiné aplikace bez použití IPC. Tento problém jsem vyřešil TCP komunikací se skriptem běžícím
		v procesu GDB. Jelikož je ale toto řešení komplikovanější než ostatní způsoby práce s GDB a při testování
		nebylo stabilní, tak jsem jeho implementaci nadále nerozšiřoval.
		
		\subsubsection{Python API pro LLDB}
		Stejně jako GDB, i LLDB poskytuje API v Pythonu. Lze jej načíst do procesu LLDB a automatizovat tak průběh ladění, stejně jako u dříve zmíněného GDB
		rozhraní. Navíc jej ale lze také použít jako knihovnu, která sama vytváří instanci LLDB a je tedy jednoduché ji použít přímo v externím kódu.
		Pomocí tohoto API jsem vytvořil komunikační vrstvu, která implementuje většinu potřebných funkcí pro tvorbu vizualizačního nástroje.
		Nicméně stejně jako celé LLDB je toto API zatím ve vývoji a obsahuje drobné chyby, například nepřesné zobrazování stavu vláken. Kvůli těmto nedostatkům
		jsem do této implementace nepřidával podporu ladění vícevláknových aplikací.
		
		\subsubsection{Protokol GDB MI}
		MI je protokol pro ovládání GDB pomocí textových příkazů, které jsou narozdíl od klasických příkazů používaných při manuálním ovládání debuggeru
		přizpůsobené pro jednoduché strojové zpracování. Obdobně jako Python API pro GDB poskytuje MI rozhraní pouze pro nejpoužívanější funkce.
		Zbytek funkcí lze používat pomocí běžných textových příkazů. Použití MI je běžným a doporučeným \cite{gdb-mi-usage} způsobem pro programovou komunikaci
		s GDB a tvorbu grafických rozhraní. Existují volně dostupné knihovny pro Python i C/C++, které umí komunikovat pomocí MI protokolu, nicméně za
		účelem pochopení fungování tohoto protokolu a možnosti přizpůsobení komunikace jsem vytvořil vlastní komunikační modul, který je popsán dále v textu.
		
		\begin{description}
			\item[Komunikace s debuggerem]
			Aby GDB umělo komunikovat pomocí MI, tak se nejprve musí přepnout do MI módu, což lze pomocí parametru předaného při spuštění. V tomto módu
			lze na jeho standardní vstup zaslat textové zprávy, které se vyhodnotí a vrátí výsledek. Formát zpráv je daný speficikací
			\footnote{https://sourceware.org/gdb/onlinedocs/gdb/GDB\_002fMI-Command-Syntax.html} a je přizpůsoben strojovému zpracování. Zprávy z debuggeru
			vždy obsahují hlavičku, která určuje, o jaký typ zprávy jde, a tělo, které obsahuje případné další informace o vyvolané události nebo
			provedeném příkazu. GDB/MI má sice definovaný základní formát zpráv, nicméně věci závislé na konkrétním laděném programu, jako jsou hodnoty proměnných,
			můžou být odesílány v různých formátech (popř. jsou místo nich dosazeny chybové hlášky), a toto chování není nikde zcela zdokumentováno.
			Může se tedy stát, že GDB vrátí data, která nepůjdou zpracovat a budou ignorována. Vzhledem k tomuto faktu a také toho, že
			struktura MI zpráv velmi podobná syntaxi formátu JSON\footnote{http://www.json.org}, který je jedním z dnešních standardních formátů pro výměnu dat,
			jsem se rozhodl tyto zprávy nejprve předzpracovat a poté je zpracovat JSON parserem, místo psaní vlastního parseru pro MI formát zpráv.
			Po odeslání příkazu knihovna čeká, než jí přijde odpověď, která musí následovat po každém příkazu.
			
			\parspace Kromě této synchronní komunikace (zaslání příkazu - přijetí odpovědi) posílá GDB také zprávy o asynchronních událostech, jako je např.
			vytvoření vlákna nebo zastavení procesu. Grafické rozhraní debuggeru musí na tyto zprávy reagovat ihned poté, co jsou debuggerem zaslány.
			Kvůli toho se v komunikačním modulu vytváří samostatné vlákno, které v pravidelném časovém intervalu kontroluje výstup z debuggeru a pokud zjistí, že došlo
			k asynchronní události, tak vyvolá vlastní událost, ke které se může přihlásit libovolný klient. Při tomto periodickém čtení může dojít k souběhu, pokud
			by během čtení přišel od klienta knihovny požadavek na odeslání příkazu, který se také snaží číst výstup z GDB při čekání na svou odpověď.
			Z tohoto důvodu je čtení výstupu debuggeru zamknuto mutexem\cite[80]{tanenbaum}, který potenciální souběh (chybu způsobenou nepředvídatelnou
			současnou změnou dat) vylučuje.
			
			\parspace Některé funkce knihovny jsou naimplementované jinak než zasláním textového příkazu do GDB, například přerušení programu, které
			slouží k zastavení programu v libovolnou chvíli. Přerušení je vyvoláno tak, že se procesu zašle signál SIGINT, který vyvolá zastavení procesu v GDB a to
			už je následně zpracováno knihovnou standardně, jako by se jednalo o zastavení při breakpointu. Stejně tak násilné ukončení programu jej nejprve přeruší,
			a teprve poté pošle GDB příkaz k ukončení laděného procesu.
			
			\item[Komunikace s laděným procesem]
			GDB implicitně přesměrovává veškerý výstup z laděného procesu na svůj vlastní výstup. Toto chování není pro komunikační mezivrstvu vhodné,
			jelikož se výstup a vstup laděného procesu mísí s vstupem a výstupem samotného ovládání GDB.
			Pro vyřešení tohoto problému lze v GDB pomocí příkazu \textit{-inferior-tty-set} nastavit terminál, s kterým bude laděný proces komunikovat.
			Při použití tohoto řešení se mi nepovedlo komunikovat s procesem v reálném čase kvůli vnitřnímu bufferování v terminálu.
			Rozhodl jsem se tedy použít jiné řešení, které při komunikaci s laděným procesem naprosto obchází GDB a je tak nezávislé na použitém debuggeru.
			
			\parspace Před zapnutím laděného procesu se v systémové složce pro dočasná data vytvoří čtyři speciální soubory, jeden pro vstup, dva pro výstup
			(klasický a chybový) a jeden pro alokace, které jsou popsány dále v textu. Komunikace se soubory je znázorněna na obrázku \ref{fig:DebugeeIO}.
			Tyto soubory jsou vytvořeny pomocí systémového volání \textit{mkfifo}\footnote{http://linux.die.net/man/3/mkfifo}, které vytváří pojmenovanou rouru.
			Pojmenované roury jsou prostředky komunikace mezi procesy (IPC), které mohou existovat i po skončení procesu, který je vytvořil, a jsou globálně
			dostupné v celém systému, ne pouze v rámci procesu a jeho potomků, jako je tomu u klasických rour. Pojmenované roury jsou reprezentované (speciálním)
			souborem na disku, který lze klasicky otevřít pro čtení nebo zápis a komunikovat tak v reálném čase mezi procesy. Tato komunikace nicméně neprobíhá 
			přes souborový systém, ale efektivně přímo v operační paměti\footnote{http://linux.die.net/man/7/fifo}.
			Narozdíl od klasických souborů ale musí být otevřené na obou svých koncích zároveň (tj. pro čtení i zápis), než je lze použít pro předání dat.
			Pokud se tedy nějaký proces pokusí otevřít rouru pro čtení, bude zablokován, dokud se nějaký jiný proces nepokusí otevřít danou
			rouru pro zápis a naopak.
			
			\remark{Pokud je pojmenovaná roura otevřena v neblokujícím režimu, lze ji otevřít pro čtení, i pokud ji ještě nikdo neotevřel pro zápis. Pokud je však
			v neblokujícím režimu otevřena pro zápis, tak otevření selže.}
			
			Na straně knihovny se tyto soubory otevřou a pomocí nich lze zapisovat data na standardní vstup laděného procesu anebo číst data z jedho standardního
			(i chybového) výstupu. Při zapnutí laděného procesu v GDB je poté jeho standardní výstup i vstup přesměrován do těchto souborů.
			Po ukočení laděného procesu se tyto pojmenované roury smažou, aby se v systému nehromadily.
			
			\InsertFigure{Figures/bak_io_alloc}{\textwidth}{Komunikace s laděným procesem}{fig:DebugeeIO}
			
			\item[Detekce dynamických alokací]
			\textit{Devi} sleduje dynamické alokace paměti na haldě laděného procesu, aby mohl zobrazovat stav adresního prostoru procesu a upozorňovat na některé
			chyby způsobené špatnou prací s pamětí. Systémová knihovna jazyka C obsahuje implementaci alokátoru, který se stará o alokaci a dealokaci paměťových
			bloků na haldě. Pro tuto práci s dynamickou pamětí se v jazyce C používají funkce \textbf{malloc}, \textbf{calloc}, \textbf{realloc}
			a \textbf{free}. V jazyce C++ se používají operátory \textbf{new} a \textbf{delete}, které ovšem také vnitřně volají již zmíněné C funkce, takže není
			nutné je explicitně zaznamenávat. Aby šlo sledovat alokace, je nutné zachytit volání všech funkcí pracujících s dynamickou pamětí a zaznamenat si
			jejich parametry a návratové hodnoty. Zachycení volání těchto funkcí lze zajistit různými způsoby. Já jsem si určil jako podmínkou to, aby šlo pracovat
			přímo se spustitelným souborem a nebyla vyžadována úprava zdrojového kódu programu.
			Nutnost úpravy zdrojového kódu by totiž byla nepraktická u větších programů, navíc by ani nešla provést pro externí knihovny, které jsou dostupné pouze
			jako binární distribuce.
			S ohledem na tyto požadavky jsem navrhl a otestoval následující způsoby sledování alokací.
			\begin{description}
				\item[Zastavení procesu při alokaci] Pokud se na všechna volání alokačních funkcí umístí breakpoint, tak proces se zastaví při jakékoliv práci s
				dynamickou pamětí. Poté si z něj lze přečíst údaje o alokaci, zaznamenat si je a obnovit běh procesu. Toto řešení se ukázalo jako funkční,
				ale zastavování procesu při každé alokaci laděný proces zpomalovalo. Dále vytváření skrytých breakpointů a jejich odlišení od breakpointů vytvořených
				uživatelem zkomplikovalo implementaci komunikační knihovny. Navíc by se tento způsob zachytávání musel
				implementovat pro každý debugger zvlášť. Kvůli těmto důvodům jsem se rozhodl toto řešení nepoužít.
				
				\item[Obalení alokačních funkcí vlastními funkcemi] Alokační funkce v jazyce C jsou definovány v systémové knihovně, která poskytuje
				implementaci standardních funkcí a systémových volání. Často používanou implementací této knihovny na Linuxových systémech je glibc
				\footnote{https://www.gnu.org/software/libc/}. Při spuštění procesu na Linuxu se vyhledají dynamické knihovny, které daný proces vyžaduje,
				a poté se namapují do jeho adresního prostoru. Použitím proměnné prostředí \textbf{LD\_PRELOAD} lze určit
				seznam sdílených knihoven, které budou přednostně nahrány ke spouštěnému procesu\footnote{http://linux.die.net/man/8/ld.so}.
				Jelikož se tyto knihovny nahrávají jako první, symboly obsažené v nich mají přednost před později nahranými symboly. Pokud se tedy pro proces
				nahrají dvě sdílené knihovny, které obě obsahují vlastní implementaci funkce se stejnou hlavičkou, tak při zavolání této funkce se použije
				implementace z knihovny, která byla nahrána dříve.
				
				\parspace Této skutečnosti jsem využil pro vytvoření sdílené knihovny, která obsahuje deklarace dříve zmíněných alokačních funkcí.
				Při spuštění procesu je nahrána před systémovou knihovnou jazyka C a všechny dynamické alokace z laděného procesu poté volají funkce z mé knihovny.
				V ní dochází k otevření pojmenované roury, která slouží ke komunikaci s komunikačním rozhraním. % TODO: lepší název
				Při alokaci či dealokaci se nejprve odešlou informace o jejím typu a případné další parametry, jako je velikost alokovaných dat
				nebo adresa dealokované paměti. Poté je zavolána původní funkce ze systémové knihovny, která provede samotnou (de)alokaci.
				Adresa původní funkce musí být zjištěna za běhu programu pomocí
				funkce \textbf{dlsym}\footnote{http://linux.die.net/man/3/dlsym}. Prosté použití jejího názvu by totiž vyústilo v nekonečné rekurzivní volání, jelikož
				by se opět zavolala funkce z přednačtené knihovny. Funkce \textbf{dlsym} nicméně sama může alokovat malé množství dynamické paměti,
				její naivní použití by tedy vyústilo v nekonečnou rekurzi a přetečení zásobníku.
				Aby k tomuto nedošlo, tak se ve sdílené knihovně vytváří statické pole s 1024 vynulovanými
				byty, které je použito pro přidělení paměti vyžádané před nebo během načítání adresy alokačních funkcí. Pokud později dojde k dealokaci této
				paměti pomocí funkce \textbf{free}, tak je tato dealokace ignorována a není předána dále do systémové knihovny, protože ta nemá o této statické paměti
				žádné informace. V komunikační vrstvě běží vlákno, které se stará výhradně o čtení informací o alokacích. Uchovává si jejich seznam
				a umožňuje jiným komponentám reagovat na alokace v reálném čase pomocí událostí.
				
				\parspace Nevýhodou tohoto řešení je, že nebude fungovat, pokud bude laděný program používat staticky přilinkovanou systémovou knihovnu
				\footnote{Linker \textit{ld} připojuje knihovny k spustitelnému souboru staticky při použití přepínače \textbf{-static}}.
				Tato situace ale není obvyklá a v případě potřeby může tvůrce laděného programu pro účely ladění systémovou knihovnu linkovat dynamicky.
				Otevření souboru pro komunikaci a získávání adresy původních funkcí dále musí být synchronizováno, aby nedošlo k souběhu u vícevláknových aplikací.
				Toto řešení však nevyžaduje zastavení procesu při každé alokaci a poskytuje zachytávání alokačních funkcí nezávislé na použitém debuggeru, proto
				jsem se jej rozhodl v \textit{Devi} použít.
				
				\remark{Pro alokaci a namapování paměti lze využít i další funkce, např. \textbf{mmap} nebo \textbf{memalign}.
				Jejich explicitní používání v programech ale není běžné, takže je \textit{Devi} nesleduje.}
			\end{description}
		\end{description}
			
	\subsection{Vizualizační aplikace}
	Pro samotné ladění aplikací a využití komunikační knihovny jsem vytvořil GUI aplikaci \textit{Devi}.
	Ta poskytuje grafické rozhraní pro veškeré naimplementované funkce knihovny a dále k nim přidává vizualizaci paměti procesu.
	Z popsaných implementací komunikace s debuggerem jsem zvolil GDB/MI protokol, protože byl nejstabilnější. Nicméně uživatelské rozhraní používá výhradně
	mnou navržené API popsané v sekci \ref{sec:DebuggerApi}, takže implementaci komunikační vrstvy lze v případě potřeby jednoduše zaměnit za jinou.
	Jelikož se chování a výstupy příkazů GDB v různých verzích značně liší, tak se nelze spoléhat na verzi GDB nainstalovanou v systému.
	Komunikační vrstva předpokládá spolupráci s GDB ve verzi 7.10.1 (ta je v současnosti nejaktuálnější). Při kompilaci projektu se tato verze GDB stáhne a
	nainstaluje do složky projektu (podrobnější informace jsou uvedeny v příloze \ref{appendix:manual}).
	
	\remark{Přibalení konkrétní verze debuggeru používají i jiné uživatelské rozhraní nebo vývojové prostředí, například CLion.}
	
	\parspace \textit{Devi} při svém spuštění vytvoří instanci komunikačního rozhraní pro ovládání debuggeru. Komunikační mezivrstva je asynchronní,
	nelze například dopředu předvídat, v který okamžik se proces zastaví, kdy se vytvoří nové vlákno atd. Pro obsluhu těchto událostí jsem použil návrhový vzor
	Observer\cite[326]{gof}, který umožňuje jednoduše reagovat na libovolné události v aplikaci. Při vyvolání události v debuggeru (změna stavu procesu,
	alokace, změna zásobníkového rámce, když je proces zastavený) se aktualizuje uživatelské rozhraní. To je díky tomu udržováno aktuální a konzistentně zobrazuje
	stav debuggeru. Jelikož události komunikační vrstvy jsou obvykle vyvolané jiným než hlavním vláknem, tak při jejich obsluze nelze přímo modifikovat uživatelské
	rozhraní. V GTK+, stejně jako u většiny ostatních GUI frameworků, lze totiž pracovat s rozhraním pouze z hlavního, tzv. GUI vlákna. Pokud je tedy pro
	obsluhu události nutná změna GUI, tak se do fronty hlavního vlákna vloží funkce (případně i s parametry), která bude hlavním vláknem zavolána,
	až zpracuje dříve vzniklé události. Protože je velmi lehké zapomenout na zákaz úpravy GUI z jiných vláken (což může, ale také nemusí způsobit pád
	aplikace, a to je velmi nepříjemné pro ladění), tak jsem vytvořil dekorátor, který tato volání blokuje. Pokud dekoruje funkci, tak při jejím zavolání
	nejprve pomocí inspekce zásobníku zkontroluje, jestli je současné vlákno hlavní, a pokud není, tak vyvolá výjimku. Při použití tohoto dekorátoru u všech
	funkcí manipulujících s uživatelským rozhraním lze spolehlivě odchytit veškeré modifikace GUI z jiných vláken.
	
	\subsubsection{Vykreslovací komponenta}
	Pro vykreslování paměti procesu jsem vytvořil komponentu, která se stará o vykreslování a rozložení jednoduchých dvojrozměrných objektů
	(čtyřúhelníky, Bézierovy křivky, obrázky, text atd.). Pro nízkoúrovňové kreslící operace používá Cairo\footnote{http://cairographics.org}, univerzální
	open-source 2D grafickou knihovnu, která je kompatibilní s nástrojem GTK+. Třídní diagram této komponenty si lze prohlédnout na obrázku
	\ref{fig:DeviCanvasUML}. % TODO: obrázek
	
	\begin{tikzpicture}
			%\umlclass{Canvas}{scale : float \\}{}
			\umlclass{Drawable}{margin : Margin \\
													padding : Padding}{}
			\umlassoc[arg2=children, mult2=*, pos2=1]{Drawable}{Drawable}

%\umlassoc[geometry=-|-, arg1=tata, mult1=*, pos1=0.3, arg2=toto, mult2=1, pos2=2.9, align2=left]{C}{B}
%\umlunicompo[geometry=-|, arg=titi, mult=*, pos=1.7, stereo=vector]{D}{C}
%\umlimport[geometry=|-, anchors=90 and 50, name=import]{sp2}{sp1}
%\umlaggreg[arg=tutu, mult=1, pos=0.8, angle1=30, angle2=60, loopsize=2cm]{D}{D}
%\umlinherit[geometry=-|]{D}{B}
%\umlnote[x=2.5,y=-6, width=3cm]{B}{Kommentar zu classe B}
%\umlnote[x=7.5,y=-2]{import-2}{blubber die blub}

	\end{tikzpicture}

	
	Třída \textbf{Canvas} slouží jako plátno; udržuje hierarchii vykreslovaných objektů, deleguje na ně události myši a klávesnice a aplikuje globální transformace
	(translace a změnu měřítka). Sama o sobě je grafickou komponentou GTK, takže ji lze transparentně použít jako součást GUI.
	Obsahuje několik kreslících vrstev, do kterých lze uložit kreslící příkazy, které se provedou v určeném pořadí, jakmile jsou ostatní kreslící operace dokončeny.
	To umožňuje vykreslovat objekty do různých vrstev v na sobě nezávislém pořadí.
	Vykreslovatelné objekty reprezentuje třída \textbf{Drawable}, která je uspořádána do stromové struktury dle návrhového vzoru
	\textit{Composite}\cite[183]{gof}. Každá její instance může tvořit buď list stromu, který se umí sám vykreslit, anebo obsahuje potomky, na které deleguje
	uživatelský vstup a určuje jejich rozvržení v prostoru. Ke změně rozvržení jednotlivých prvků je k dispozici určení pozice, vnější a vnitřní mezery
	a určení minimálních, maximálních a požadovaných rozměrů. Podle těchto omezení se vypočte rozměr a ohraničující obdélník objektu a objekty poté mohou být
	svými rodiči vyskládány na plátno.
	Tato sada vlastností umožňuje vykreslit jednoduché struktury objektů, které stačí pro základní zobrazení stavu paměti běžícího procesu.
	Dále je ještě k dispozici několik vlastností pro změnu stylu (například barva pozadí nebo rámeček). Abych do této komponenty
	nemusel reimplementovat komplexní uživatelské prvky, jako je zadávání vstupu, tak v ní lze vytvořit prvek, který obaluje libovolný GTK grafický prvek,
	který je poté absolutně pozicován na plátno.
	Takto obalené komponenty ale nefungují správně při posunutém nebo škálovaném plátně. % TODO: relax scale/translate constraint?
	
	\parspace Pomocí této komponenty jsem vytvořil několik tříd specializovaných na vykreslování datových typů jazyka C a C++. Aplikace při zastavení laděného
	procesu načte z debuggeru zásobníkové rámce spolu s jejich proměnnými a dále také všechny objekty, na které ukazují ukazatele ze zásobníku.
	Všechny proměnné jsou rekurzivním průchodem namapovány na odpovídající vykreslovací komponentu, která je předána plátnu k vykreslení.
	Následuje seznam kreslících prvků specializovaných na jednotlivé datové typy programů. Jejich přehled je na obrázku \ref{fig:DeviDrawableOverview}.
	
	\begin{description}
		\item[Jednoduché datové typy] Primitivní datové typy (čísla, znaky atd.), řetězce, výčtové typy (enumerace) a typy, které nelze plně vizualizovat
		(funkce), jsou zobrazeny klasickým textovým popisem. Při kliknutí na ně se zobrazí textový vstup, pomocí kterého lze změnit jejich hodnota.
		\item[Ukazatele] Ukazatele a reference jsou vizualizovány šipkou (její dráha je určena kubickou Bézierovou křivkou), která ukazuje na objekt na adrese
		dané ukazatelem či referencí. % TODO: drag and drop?
		\item[Složené datové typy] Struktury, třídy a svazy (typ \textbf{union}) jsou reprezentovány hierarchicky. U každého atributu struktury je zobrazen jeho
		název a hodnota, jejíž podoba závisí na jeho datovém typu. Jelikož mapování proměnných na kreslitelné objekty probíhá rekurzivně, lze takto zobrazit
		libovolně zanořené hierarchické struktury.
		\item[Kolekce] Pole a dynamické vektory (typ \texttt{std::vector} ze standardní šablonové knihovny C++) jsou reprezentované horizontálním výčtem svých prvků.
		Jelikož takovéto kolekce můžou obsahovat obrovský počet prvků, tak je vždy načtena a zobrazena vždy pouze jejich část. Pomocí dvou přepínačů lze u každé
		kolekce zvolit, kolik prvků se z ní má zobrazit a na které pozici v kolekci má zobrazený výčet začínat. Aby se krátké kolekce nemusely zdlouhavě rozklikávat,
		tak se implicitně pro každou kolekci zobrazuje prvních deset prvků.
	\end{description}
	
	Ze standardní šablonové knihovny jazyka C++ obsahuje \textit{Devi} speciální zobrazení pro kontejner typu \texttt{std::vector}. Ten je často používanou
	reprezentací pole s dynamickou velikostí a proto se v \textit{Devi} zobrazuje stejně jako klasické pole. Ostatní kontejnery a třídy ze standardní knihovny
	nemají speciální vykreslovací třídu a jsou tak zobrazeny jako třídy (výčtem svých atributů).
	% TODO: přidat vykreslení pro více STL tříd?
	
	\subsubsection{Používání aplikace}
	Na obrázku \ref{fig:DeviGui} je zobrazeno rozhraní aplikace. Následuje popis funkcí a popis použití jednotlivých částí rozhraní.
	% TODO: obrázek panelu nástrojů
	
	\remark{Většina oken a panelů v \textit{Devi} popisuje nebo modifikuje stav laděného procesu a z toho důvodu s nimi lze pracovat pouze když je proces
	zastavený. Dnešní počítače zvládnou provádět miliardy operací za vteřinu a tak častá aktualizace informací o stavu procesu by postrádala smysl.}
	
	\InsertFigure{Figures/devi_gui}{\textwidth}{Uživatelské rozhraní Devi}{fig:DeviGui}
	
	\begin{description}
		\item[Hlavní menu] V menu lze načíst spustitelný soubor aplikace, což je nutný první krok, pokud tuto aplikaci chceme v \textit{Devi} ladit.
			Spustitelný soubor musí být přeložený s ladícími symboly, jinak ladění nebude spolehlivě fungovat. Dále zde lze upravit spouštění laděného procesu.
			Nastavit jdou předané parametry prostředí a příkazové řádky a pracovní adresář procesu.
		\item[Panel ovládání procesu] Tento panel obsahuje nejpoužívanější příkazy sloužící k ovládání běhu procesu, jako je jeho zapnutí, přerušení, násilné
			ukončení a několik typů krokování. Jednotlivé příkazy jsou automaticky blokovány a povolovány podle stavu laděného procesu, nelze tedy např. zapnout
			proces, když už běží, anebo ho krokovat, když není zastavený.
		\item[Zdrojový kód] \textit{Devi} obsahuje okno, které zobrazuje obsah zdrojového kódu souboru v textovém editoru. Zobrazeno může být několik souborů naráz,
			lze mezi nimi přepínat pomocí záložek. Při načtení spustitelného souboru se automaticky načte a zobrazí soubor, který obsahuje vstupní bod daného programu
			(funkci \textit{main}). Pokud se laděný proces zastaví na breakpointu v nějakém zdrojovém souboru, tak je tento soubor automaticky otevřen a zobrazen
			v editoru a ten se posune tak, aby byl daný breakpoint vidět a uživatel ho nemusel hledat. Pokud chce uživatel manuálně přidat breakpoint v jiném, než
			hlavním zdrojovém souboru, může využít funkce načtení libovolného zdrojového souboru z hlavního menu. Samotný textový editor nepovoluje změny zdrojového
			kódu, jelikož k tomu debugger není určen a neobsahuje ani žádnou vestavěnou podporu překladu kódu do spustitelné podoby. Kód je tak zobrazen pouze pro
			čtení, aby náhodou nedošlo k jeho nechtěné změně. Ve sloupci vedle zdrojového kódu lze přidávat a odebírat breakpointy. Zároveň se v něm při běhu procesu
			ukazuje, na kterém řádku v daném souboru je proces zastavený. Pokud je laděný proces zastavený, tak při přesunutí kurzoru myši nad proměnnou ve zdrojovém
			kódu se zobrazí její současná hodnota v procesu. Tuto funkcionalitu zajišťuje knihovna Clang\footnote{http://clang.llvm.org}, což je parser a překladač
			jazyků C, C++ a Objective C, který kód dále překládá do formátu překladače LLVM.
		\item[Konzole] Pomocí konzole lze komunikovat s laděným procesem. Zobrazuje se v ní obsah jeho standardního (\textit{stdout}) i chybového (\textit{stderr})
			výstupu. Lze do ní také psát text, který se po odřádkování odešle laděnému procesu. Výstup, chybový výstup i vstup lze jednotlivě skrýt pomocí
			zaškrtávacích tlačítek.
		\item[Zásobník funkcí] V tomto okně je zobrazen stav zásobníku volaných funkcí pro aktivní vlákno. Lze se mezi nimi přepínat, což způsobí aktualizaci
			ukazatele současného řádku v editoru zdrojového kódu. Mezi zásobníkovými rámci lze přepínat i pomocí vizualizačního plátna, které je popsáno dále.
		\item[Seznam vláken] Zde je zobrazen seznam všech vláken laděného procesu spolu s jejich základními informacemi, jako je název nebo id. Pokud je proces
			zastavený, lze se mezi přepínat. Jelikož změna vlákna způsobí i změně zásobníku funkcí, tak při ní dochází ke kompletnímu překreslení vizualizačního
			plátna.
		\item[Seznam registrů]
			Pokud je proces zastavený, tak je zde zobrazen seznam názvů a hodnot všech registrů procesoru. To může sloužit k nízkoúrovňovému ladění procesu, např.
			při práci s jazykem symbolických adres.
		\item[Zobrazení paměti] V tomto okně lze zadat hexadecimální adresu paměti, ze které se načte 160 bytů, které jsou poté zobrazeny ve formě dvou tabulek.
			V první tabulce je přímá hodnota bytů ve formě čísla o rozsahu 0 až 255, ve druhé tabulce je pak jejich ASCII reprezentace, vhodná pro zkoumání textových
			polí v paměti. Kromě adresy v paměti lze zadat také název proměnné ze současně aktivního zásobníkového rámce. Adresa této proměnné se poté odvodí
			a zobrazí se hodnota její paměti.
		\item[Detail haldy]
			Toto okno zobrazuje graf velikosti paměti alokované na haldě v závislosti na čase. Pokud laděný proces běží, tak se hodnota grafu aktualizuje co vteřinu
			a zobrazuje tak stav haldy v reálném čase. Dále se zde zobrazuje současný počet naalokovaných bloků na haldě, její velikost v bytech a celkový počet
			alokací a dealokací zaznamenaných od spuštění procesu.
		\item[Vizualizační plátno] Na tomto plátně se při zastavení procesu vykreslí všechny jeho zásobníkového rámce (pro aktivní vlákno). V každém rámci je
			vykreslen seznam lokálních proměnných a parametrů dané funkce. U každé proměnné je zobrazen její název a současná hodnota, při podržení myši nad ní se dále
			zobrazí dodatečné informace, jako je její adresa v paměti. Na jednoduché typy proměnných, jako jsou primitivní datové typy (\textit{int}, \textit{bool}
			aj.), lze po kliknutí změnit jejich hodnotu pomocí textového pole. Aktivní zásobníkový rámec lze změnit kliknutím na hlavičku některého z vykreslených
			rámců, současný aktivní rámec je zvýrazněn červenou barvou.		
	\end{description}

\end{section}
\begin{section}{Testování dosažených výsledků}
% TODO: ukázat sort, paměťové a CPU nároky
\end{section}
\begin{section}{Závěr}
\label{sec:Conclusion}
Po otestování \textit{Devi} na reálných zdrojových kódech a programech jsem došel k závěru, že vizualizace paměti procesu může poskytnout obstojnou
alternativu k prosté textové reprezentaci. Lze si díky ní lépe představit rozmístění paměti v adresním prostoru procesu a rychleji pochopit vztahy mezi objekty.
Nicméně objem paměti používané programy je v dnešní době obrovský a zobrazit jej naráz není možné. Grafická forma paměti také zabírá mnohem více místa než textový
popis a z toho důvodu nemusí stačit k zobrazení všech proměnných a částí paměti, které programátora ladícího daný proces zajímají. Pro největší flexibilitu
při ladění je tedy vhodné zkombinovat oba dva způsoby reprezentace paměti procesu.

\parspace \textit{Devi} by mohl být v budoucnu rozšířen o další užitečné funkce. Pokud by se do něj přidala jednoduchá správa souborů a možnost překladu
zdrojového kódu, mohl by sloužit jako jednoduché vývojové prostředí pro výuku programování v jazycích C a C++.
Díky tomu, že obsahuje komunikační knihovnu s abstraktním API je jednoduché přidat k němu podporu pro další debuggery. Určitě by bylo
zajímavé rozšířit tuto vrstvu o komunikaci s jinými debuggery, než je GDB, a srovnat jejich funkcionalitu a stabilitu.
Komunikační knihovnu by také šlo rozšířit o více funkcí, například o ladění po síti nebo připojování se k již běžícím procesům.
Vizualizaci objektů by šlo také dále prohlubovat, např. vytvářením odlišných pohledů nad stejnými daty, přidáním diagramů zobrazujících rozsáhlá data nebo
přidáním podpory pro všechny paměťové kontejnery standardní knihovny jazyka C++. Pro alternativu k grafické reprezentaci by také šlo přidat klasické textové
zobrazení proměnných ve stromové struktuře. Pro velké programy může načítání vizualizace paměti trvat dlouhou dobu, pro omezení tohoto problému by se dalo
použít například načítání na požádání (lazy loading).
\end{section}

\bigskip
\begin{flushright}
Jakub Beránek
\end{flushright}

%\printbibheading[title=Zdroje, heading=bibintoc]
\printbibliography % TODO: do obsahu

\appendix
\begin{section}{Struktura projektu a instalační manuál}
\label{appendix:manual}
	% TODO: examples
	Projekt, který je přiložen na DVD, má následující adresářovou strukturu.
	
	\vspace{5mm}
	
	\dirtree{%
	.1 /.
	.2 debugger\DTcomment{zdrojové kódy komunikační knihovny}.
	.3 analysis\DTcomment{analýza kódu}.
	.3 gdbc\DTcomment{komunikace s GDB pomocí GDB Python API}.
	.3 lldbc\DTcomment{komunikace s LLDB pomocí LLDB Python API}.
	.3 mi\DTcomment{komunikace s GDB pomocí textového MI rozhraní}.
	.3 net\DTcomment{síťová komunikace mezi debuggerem a klientem}.
	.3 pycgdb\DTcomment{experimentální implementace debuggeru v Pythonu}.
	.2 gui\DTcomment{zdrojové kódy uživatelského rozhraní}.
	.3 drawing\DTcomment{kreslící framework a vizualizace paměti}.
	.2 res\DTcomment{vizuální zdroje aplikace}.
	.3 css\DTcomment{CSS styly pro úpravu vzhledu aplikace}.
	.3 gui\DTcomment{Glade soubory s nákresy GUI prvků}.
	.3 img\DTcomment{obrázky}.
	.2 tests\DTcomment{unit testy}.
	.3 src\DTcomment{zdrojové kódy C++ aplikací pro unit testy}.
	.2 util\DTcomment{pomocné skripty}.
	}
	
	\parspace Pro kompletní instalaci programu je nutné mít GTK3+ (verze 3.10.8 nebo vyšší), překladač C++ a Pythonovské balíčky \texttt{enum},
	\texttt{matplotlib} a \texttt{clang}. Pro spuštění testů je potřeba balíček \texttt{pytest} (ve verzi pro Python 2) a
	pro vygenerování dokumentace balíček \texttt{epydoc}. O sestavení programu se stará program \textit{waf}. Pro jeho použití stačí spustit v interpreteru
	příkazové řádky ve složce projektu \texttt{./waf <příkaz>}. Je možné pro něj použít následující příkazy.
	
	\begin{description}
		\item[configure] nakonfiguruje projekt, tento příkaz musí být zavolán před příkazem \texttt{build}
		\item[build] přeloží sdílenou knihovnu pro zachytávání alokací a stáhne a přeloží GDB 7.10.1
		\item[docs] vygeneruje dokumentaci programu do složky docs
		\item[download] stáhne všechny potřebné programy a balíčky pro běh aplikace pomocí balíčkového manažeru \textit{Aptitude}
		\item[cleanall] vymaže dokumentaci, zkompilované soubory sdílené knihovny a GDB a soubory s byte kódem Pythonu
	\end{description}
	
	\parspace Pro rychlou instalaci lze použít přiložený skript \texttt{install.sh}, který provede \textit{waf} příkazy \texttt{download}, \texttt{configure}
	a \texttt{build} (v tomto pořadí).
	Pro otestování aplikace lze použít příkaz \texttt{py.test} ve složce tests.
	Program lze spustit pomocí skriptu \texttt{start.sh} v kořenovém adresáři projektu anebo spuštěním Python skriptu \texttt{initialize.py} ve složce \texttt{gui}.
	
	\vspace{5mm}
	
	Projekt je verzován pomocí verzovacího systému \textit{git} a je dostupný také online na adrese \url{https://github.com/Kobzol/debug-visualizer}.
\end{section}

\begin{section}{Ukázky grafických rozhraní debuggerů}
\label{appendix:gui}
	\InsertFigure{Figures/appendix_gui_gdb_tui}{\textwidth}{Textové rozhraní GDB (TUI)}{fig:AppendixGuiGdbTui}
	\InsertFigure{Figures/appendix_gui_ddd}{\textwidth}{Rozhraní programu DDD}{fig:AppendixGuiDDD}
	\InsertFigure{Figures/appendix_gui_clion}{\textwidth}{Rozhraní programu CLion (zdroj: https://www.jetbrains.com/clion)}{fig:AppendixGuiClion}
\end{section}

\clearpage

\end{document}
